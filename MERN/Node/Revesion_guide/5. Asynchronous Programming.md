# **ğŸ“Œ Asynchronous Programming in Node.js (Interview Guide)**

## **1ï¸âƒ£ What is Asynchronous Programming?**

Asynchronous programming allows operations to execute **without blocking** the execution of other tasks. In Node.js,  **I/O operations** ,  **database queries** , and **network requests** are handled asynchronously, improving efficiency and scalability.

ğŸ‘‰ **Why Asynchronous Programming?**

âœ… Non-blocking execution

âœ… Handles multiple requests efficiently

âœ… Better performance for I/O-intensive tasks

---

## **2ï¸âƒ£ How Node.js Handles Asynchronous Operations?**

Node.js uses **Event Loop** and **Callback Queue** to manage asynchronous execution.

ğŸ”¹ **Key Components:**

âœ” **Callbacks** â€“ Traditional approach using functions

âœ” **Promises** â€“ Modern approach with `.then()`

âœ” **Async/Await** â€“ Syntactic sugar over Promises

âœ” **Event Loop** â€“ Manages execution of asynchronous tasks

---

## **3ï¸âƒ£ Example: Synchronous vs Asynchronous**

### **ğŸ”¹ Synchronous Code (Blocking Execution)**

```js
console.log('Start');
const result = fs.readFileSync('file.txt', 'utf-8'); // Blocks execution
console.log(result);
console.log('End');
```

ğŸ“Œ **Problem:** File reading blocks further execution.

---

### **ğŸ”¹ Asynchronous Code (Non-Blocking Execution)**

```js
const fs = require('fs');

console.log('Start');
fs.readFile('file.txt', 'utf-8', (err, data) => {
    if (err) throw err;
    console.log(data);
});
console.log('End');
```

ğŸ“Œ **Output Order:**

```
Start
End
(file content)
```

âœ” **Solution:** Execution continues while `fs.readFile()` runs in the background.

---

## **4ï¸âƒ£ Callbacks in Asynchronous Programming**

A **callback** is a function passed as an argument and executed after an asynchronous operation completes.

### **ğŸ”¹ Example: Using Callbacks**

```js
function fetchData(callback) {
    setTimeout(() => {
        console.log('Data fetched');
        callback();
    }, 2000);
}

console.log('Start');
fetchData(() => console.log('Callback executed'));
console.log('End');
```

ğŸ“Œ **Problem:** Callback Hell (Nested Callbacks)

```js
doTask1(() => {
    doTask2(() => {
        doTask3(() => {
            console.log('All tasks done');
        });
    });
});
```

---

## **5ï¸âƒ£ Promises: Solving Callback Hell**

A **Promise** is an object that represents the eventual completion or failure of an asynchronous operation.

### **ğŸ”¹ Creating a Promise**

```js
const fetchData = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 2000);
    });
};

fetchData().then(data => console.log(data)).catch(err => console.log(err));
```

ğŸ“Œ **Key Methods:**

âœ” `resolve()` â†’ When operation is successful

âœ” `reject()` â†’ When operation fails

âœ” `.then()` â†’ Executes when resolved

âœ” `.catch()` â†’ Handles errors

---

## **6ï¸âƒ£ Async/Await: Cleaner Way to Handle Promises**

**Async/Await** makes asynchronous code look synchronous.

### **ğŸ”¹ Example: Fetching Data with Async/Await**

```js
const fetchData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 2000);
    });
};

const getData = async () => {
    console.log('Fetching...');
    const data = await fetchData();
    console.log(data);
};

getData();
```

ğŸ“Œ **Benefits of Async/Await:**

âœ… More readable code

âœ… Handles errors with `try/catch`

---

## **7ï¸âƒ£ Event Loop & Asynchronous Execution**

ğŸ”¹ **Node.js follows a Single-Threaded Event Loop model** to handle asynchronous tasks efficiently.

### **ğŸ“Œ Event Loop Phases:**

1ï¸âƒ£ **Timers Phase** â†’ Executes `setTimeout()` & `setInterval()` callbacks

2ï¸âƒ£ **Pending Callbacks** â†’ Executes I/O-related callbacks

3ï¸âƒ£ **Idle/Prepare Phase** â†’ Internal tasks

4ï¸âƒ£ **Poll Phase** â†’ Fetches new I/O events

5ï¸âƒ£ **Check Phase** â†’ Executes `setImmediate()` callbacks

6ï¸âƒ£ **Close Callbacks** â†’ Executes close event callbacks

### **ğŸ“Œ Event Loop in Action**

```js
console.log('Start');

setTimeout(() => {
    console.log('Timeout executed');
}, 0);

Promise.resolve().then(() => console.log('Promise resolved'));

console.log('End');
```

ğŸ“Œ **Output Order:**

```
Start
End
Promise resolved
Timeout executed
```

âœ” **Why?** Microtasks (Promises) execute before timers.

---

## **8ï¸âƒ£ Interview Questions on Asynchronous Programming**

ğŸ”¹ **What is the difference between synchronous and asynchronous programming?**

ğŸ”¹ **How does Node.js handle asynchronous execution?**

ğŸ”¹ **What is the role of the Event Loop?**

ğŸ”¹ **What is a Promise, and how does it work?**

ğŸ”¹ **Explain Async/Await with an example.**

ğŸ”¹ **Difference between `setTimeout()` and `setImmediate()`.**

---

## **9ï¸âƒ£ Quick Revision Summary**

âœ” **Synchronous Code** â€“ Blocks execution

âœ” **Asynchronous Code** â€“ Non-blocking, handled via Event Loop

âœ” **Callbacks** â€“ Function executed after async task

âœ” **Promises** â€“ `.then()/.catch()` to handle async operations

âœ” **Async/Await** â€“ Cleaner syntax for Promises

âœ” **Event Loop** â€“ Manages async tasks efficiently
