# **Objects & Prototypes - Interview Revision Guide** ğŸš€

## **1. Objects in JavaScript**

âœ” An **object** is a collection of key-value pairs where values can be **properties** (data) or **methods** (functions).

âœ” Objects help in structuring data efficiently in JavaScript.

### **Creating Objects in JavaScript**

| **Method**               | **Description**            | **Example**                                          |
| ------------------------------ | -------------------------------- | ---------------------------------------------------------- |
| **Object Literal**       | Easiest way to create an object. | `const user = { name: "Sayanta", age: 25 };`             |
| **Object Constructor**   | Using `new Object()`.          | `const user = new Object(); user.name = "Sayanta";`      |
| **Factory Function**     | Function that returns an object. | `function createUser(name) { return { name }; }`         |
| **Constructor Function** | Uses `this`and `new`keyword. | `function User(name) { this.name = name; }`              |
| **Class (ES6)**          | Modern way to define objects.    | `class User { constructor(name) { this.name = name; } }` |

---

## **2. Object Properties & Methods**

âœ” **Accessing properties**

```js
const user = { name: "Sayanta", age: 25 };

// Dot notation
console.log(user.name); // "Sayanta"

// Bracket notation
console.log(user["age"]); // 25
```

âœ” **Adding & Modifying Properties**

```js
user.email = "sayanta@example.com";
user["age"] = 26;
```

âœ” **Deleting Properties**

```js
delete user.email;
console.log(user); // { name: "Sayanta", age: 26 }
```

âœ” **Looping through Object Properties**

```js
for (let key in user) {
    console.log(`${key}: ${user[key]}`);
}
```

âœ” **Object Methods**

```js
const person = {
    name: "Sayanta",
    greet: function() {
        return `Hello, ${this.name}!`;
    }
};

console.log(person.greet()); // "Hello, Sayanta!"
```

---

## **3. Object Methods (ES6 Features)**

âœ” **Object.keys()** â†’ Returns an array of keys

```js
console.log(Object.keys(user)); // ["name", "age"]
```

âœ” **Object.values()** â†’ Returns an array of values

```js
console.log(Object.values(user)); // ["Sayanta", 26]
```

âœ” **Object.entries()** â†’ Returns key-value pairs as arrays

```js
console.log(Object.entries(user)); // [["name", "Sayanta"], ["age", 26]]
```

âœ” **Object.assign()** â†’ Copies properties to another object

```js
const user2 = Object.assign({}, user);
console.log(user2); // { name: "Sayanta", age: 26 }
```

âœ” **Spread Operator (`...`)**

```js
const user3 = { ...user, city: "Bangalore" };
console.log(user3); // { name: "Sayanta", age: 26, city: "Bangalore" }
```

âœ” **Object.freeze() & Object.seal()**

```js
const obj = { name: "John" };
Object.freeze(obj);
obj.name = "Doe"; // âŒ Won't change
```

```js
const obj2 = { name: "John" };
Object.seal(obj2);
obj2.name = "Doe"; // âœ… Allowed
delete obj2.name; // âŒ Not allowed
```

---

# **4. Prototypes in JavaScript**

âœ” Every JavaScript object has a **prototype** from which it inherits properties and methods.

âœ” **Prototype chain** allows objects to access properties and methods defined in their prototype.

---

## **5. Prototype Inheritance**

âœ” Objects can inherit properties and methods from another object via the prototype.

```js
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    return `Hello, my name is ${this.name}`;
};

const user1 = new Person("Sayanta");
console.log(user1.greet()); // "Hello, my name is Sayanta"
```

âœ” **Prototype Chain**

```js
console.log(user1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
```

âœ” **Adding Methods to Prototypes**

```js
Person.prototype.sayBye = function() {
    return "Goodbye!";
};

console.log(user1.sayBye()); // "Goodbye!"
```

---

## **6. Class Inheritance (ES6)**

âœ” `class` in ES6 is syntactic sugar over constructor functions.

```js
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        return `${this.name} makes a noise`;
    }
}

class Dog extends Animal {
    speak() {
        return `${this.name} barks!`;
    }
}

const dog = new Dog("Tommy");
console.log(dog.speak()); // "Tommy barks!"
```

---

# **7. Interview Questions on Objects & Prototypes**

âœ… **Q1:** What are objects in JavaScript, and how do they differ from arrays?

âœ… **Q2:** Explain prototype inheritance in JavaScript.

âœ… **Q3:** How does JavaScriptâ€™s prototype chain work?

âœ… **Q4:** What is the difference between `Object.create()` and class-based inheritance?

âœ… **Q5:** What is the difference between `Object.freeze()` and `Object.seal()`?


### âœ… **Q1: What Are Objects in JavaScript, and How Do They Differ from Arrays?**

---

### **1ï¸âƒ£ What Are Objects in JavaScript?**

ğŸ“Œ In JavaScript, an **object** is a collection of  **key-value pairs** , where keys (also called properties) are  **strings or Symbols** , and values can be  **any data type** .

ğŸ”¹ **Objects store data in an unordered structure.**

ğŸ”¹ They are commonly used for representing **real-world entities** like users, products, etc.

**Example of an Object:**

```js
const person = {
  name: "John",
  age: 30,
  isStudent: false,
  greet: function () {
    console.log("Hello, " + this.name);
  },
};
console.log(person.name); // Output: John
person.greet(); // Output: Hello, John
```

---

### **2ï¸âƒ£ What Are Arrays in JavaScript?**

ğŸ“Œ An **array** is a special type of object that stores **ordered** elements, typically accessed by **index numbers** starting from `0`.

ğŸ”¹ **Arrays are used when order matters.**

ğŸ”¹ **Elements are accessed using indices (`[0]`, `[1]`, etc.).**

ğŸ”¹ They provide built-in methods like `.push()`, `.map()`, and `.filter()`.

**Example of an Array:**

```js
const fruits = ["Apple", "Banana", "Mango"];
console.log(fruits[1]); // Output: Banana
fruits.push("Orange");
console.log(fruits); // Output: ["Apple", "Banana", "Mango", "Orange"]
```

---

### **3ï¸âƒ£ Key Differences: Objects vs. Arrays**

| Feature             | Objects ğŸ                                          | Arrays ğŸ“¦                                      |
| ------------------- | -------------------------------------------------- | ---------------------------------------------- |
| **Structure** | Key-value pairs `{ key: value }`                 | Ordered list `[value1, value2]`              |
| **Indexing**  | Accessed via**keys**(`object.key`)         | Accessed via**indices**(`array[0]`)    |
| **Use Case**  | Storing structured data (e.g., user info)          | Storing ordered lists (e.g., list of products) |
| **Order**     | **Unordered**                                | **Ordered**                              |
| **Iteration** | `for...in`,`Object.keys()`,`Object.values()` | `for`,`map()`,`forEach()`                |

---

### **4ï¸âƒ£ When to Use Objects vs. Arrays?**

âœ… **Use Objects** when you need **key-value relationships** (e.g., user profile, configurations).

âœ… **Use Arrays** when you need **ordered collections** (e.g., list of users, product catalog).

**Example:**

```js
const user = { id: 1, name: "Alice", email: "alice@example.com" }; // Object
const users = ["Alice", "Bob", "Charlie"]; // Array
```

---

### **5ï¸âƒ£ Interview Tip ğŸ“**

ğŸ“ **One-Liner Answer:**

*"Objects store data in key-value pairs and are unordered, while arrays store ordered lists of values accessed by index."*

ğŸ’¡ **Bonus Interview Question:**

âœ… **Q:** Are JavaScript arrays actually objects?

**A:** Yes! Arrays in JavaScript are a special type of object, with numerical keys and built-in methods for handling ordered data.



### âœ… **Q2: Explain Prototype Inheritance in JavaScript.**

---

### **1ï¸âƒ£ What Is Prototype Inheritance?**

ğŸ“Œ **Prototype inheritance** is a mechanism in JavaScript where objects inherit properties and methods from another object, known as the  **prototype** .

ğŸ”¹ **Every JavaScript object has an internal reference (`[[Prototype]]`) to another object, called its prototype.**

ğŸ”¹ **Objects inherit properties and methods from their prototype, allowing reusability and efficiency.**

ğŸ”¹ **Prototype inheritance forms the basis of JavaScriptâ€™s object-oriented programming model.**

---

### **2ï¸âƒ£ How Does Prototype Inheritance Work?**

ğŸ›  When we access a property or method on an object, JavaScript first looks for it in the object itself.

ğŸ” If it doesnâ€™t find it, JavaScript **searches the prototype chain** until it finds the property or reaches `null`.

**Example of Prototype Inheritance:**

```js
// Parent Object (Prototype)
const person = {
  greet: function () {
    console.log("Hello, " + this.name);
  },
};

// Child Object Inheriting from person
const student = Object.create(person); // student now inherits from person
student.name = "Alice"; 

student.greet(); // Output: Hello, Alice
```

Here, `student` doesnâ€™t have a `greet` method, but JavaScript finds it in the prototype (`person`).

---

### **3ï¸âƒ£ Understanding the Prototype Chain ğŸ”—**

ğŸ“Œ When an object inherits properties from another object, it creates a  **prototype chain** .

**Example:**

```js
console.log(student.__proto__ === person); // true
console.log(person.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true (end of chain)
```

ğŸ“Œ **The chain continues up to `Object.prototype`, which is the base prototype for all objects.**

---

### **4ï¸âƒ£ Prototype Inheritance Using Constructor Functions**

```js
// Constructor Function
function Animal(name) {
  this.name = name;
}

// Adding method to prototype
Animal.prototype.speak = function () {
  console.log(this.name + " makes a sound.");
};

// Creating an instance
const dog = new Animal("Dog");
dog.speak(); // Output: Dog makes a sound.
```

ğŸ“Œ **Here, `speak()` is not inside `dog`, but JavaScript finds it in `Animal.prototype`.**

---

### **5ï¸âƒ£ Class-Based Prototype Inheritance (ES6 Classes)**

In modern JavaScript, **`class` syntax** simplifies prototype-based inheritance.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + " makes a sound.");
  }
}

class Dog extends Animal {
  bark() {
    console.log(this.name + " barks!");
  }
}

const myDog = new Dog("Buddy");
myDog.speak(); // Output: Buddy makes a sound.
myDog.bark();  // Output: Buddy barks!
```

ğŸ“Œ **The `Dog` class inherits from `Animal`, so `myDog` gets both `speak()` and `bark()`.**

---

### **6ï¸âƒ£ Key Points About Prototype Inheritance**

âœ” Every object in JavaScript has a  **prototype** , which is another object.

âœ” If a property or method is **not found** in an object, JavaScript looks up the  **prototype chain** .

âœ” **`Object.create(prototype)`** creates a new object with a specified prototype.

âœ” **`__proto__`** (deprecated) and **`Object.getPrototypeOf(obj)`** can check an objectâ€™s prototype.

âœ” **ES6 classes** (`class` and `extends`) provide a cleaner way to implement prototype inheritance.

---

### **7ï¸âƒ£ Interview Tip ğŸ“**

ğŸ“ **One-Liner Answer:**

*"Prototype inheritance allows JavaScript objects to inherit properties and methods from other objects through a prototype chain, enabling code reuse and efficiency."*

ğŸ’¡ **Bonus Interview Question:**

âœ… **Q:** Whatâ€™s the difference between classical inheritance (OOP) and prototype inheritance?

**A:** Classical inheritance (e.g., Java, C++) is **class-based** and defines objects from blueprints (`class`). JavaScriptâ€™s prototype inheritance is  **object-based** , where objects inherit directly from other objects.



### âœ… **Q3: How Does JavaScriptâ€™s Prototype Chain Work?**

---

### **1ï¸âƒ£ What Is the Prototype Chain?**

ğŸ“Œ The **prototype chain** in JavaScript is a mechanism that allows objects to inherit properties and methods from other objects through a chain of  **prototypes** .

ğŸ”¹ Every JavaScript object has an **internal reference (`[[Prototype]]`)** to another object, called its prototype.

ğŸ”¹ When an object property or method is accessed, JavaScript searches the **prototype chain** until it finds the property or reaches `null`.

ğŸ”¹ The chain ensures  **code reusability and efficiency** .

---

### **2ï¸âƒ£ How Does the Prototype Chain Work?**

ğŸ” **When you access a property or method on an object:**

âœ… JavaScript  **first looks in the object itself** .

âœ… If the property/method is  **not found** , JavaScript  **checks the object's prototype** .

âœ… This continues **up the prototype chain** until it reaches `null` (the end of the chain).

---

### **3ï¸âƒ£ Example of the Prototype Chain**

```js
const parent = {
  greet: function () {
    console.log("Hello from Parent!");
  },
};

const child = Object.create(parent); // child inherits from parent
child.name = "Alice";

console.log(child.name); // Output: Alice (found in child)
child.greet(); // Output: Hello from Parent! (found in parent)
console.log(child.toString()); // Found in Object.prototype
```

ğŸ”¹ **Step-by-step lookup:**

1ï¸âƒ£ `child.name` â†’ Found in `child`.

2ï¸âƒ£ `child.greet()` â†’ Not found in `child`, found in `parent`.

3ï¸âƒ£ `child.toString()` â†’ Not in `child` or `parent`, but found in `Object.prototype`.

---

### **4ï¸âƒ£ Understanding Prototype Chain Hierarchy**

Every object in JavaScript inherits from a prototype, forming a  **hierarchy** :

```js
console.log(child.__proto__ === parent); // true
console.log(parent.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true (end of chain)
```

ğŸ›  **Hierarchy:**

`child â†’ parent â†’ Object.prototype â†’ null`

---

### **5ï¸âƒ£ Prototype Chain in Constructor Functions**

```js
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function () {
  console.log(this.name + " makes a sound.");
};

const dog = new Animal("Buddy");

dog.speak(); // Output: Buddy makes a sound.
console.log(dog.toString()); // Found in Object.prototype
```

âœ… Here, `dog` doesn't have `speak()`, so JavaScript looks for it in `Animal.prototype`.

---

### **6ï¸âƒ£ Prototype Chain in ES6 Classes**

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + " makes a sound.");
  }
}

class Dog extends Animal {
  bark() {
    console.log(this.name + " barks!");
  }
}

const myDog = new Dog("Rex");

myDog.speak(); // Found in Animal.prototype
myDog.bark();  // Found in Dog.prototype
```

ğŸ“Œ The prototype chain:

`myDog â†’ Dog.prototype â†’ Animal.prototype â†’ Object.prototype â†’ null`

---

### **7ï¸âƒ£ Checking an Objectâ€™s Prototype**

1ï¸âƒ£ Using `__proto__` (deprecated but useful for debugging):

```js
console.log(dog.__proto__ === Animal.prototype); // true
```

2ï¸âƒ£ Using `Object.getPrototypeOf(obj)`:

```js
console.log(Object.getPrototypeOf(dog) === Animal.prototype); // true
```

---

### **8ï¸âƒ£ Key Takeaways**

âœ” **Prototype inheritance enables objects to reuse methods and properties from other objects.**

âœ” **JavaScript searches the prototype chain until it finds the requested property or method.**

âœ” **The chain ends at `null`, meaning no more inheritance.**

âœ” **Using `Object.create(prototype)`, we can set an objectâ€™s prototype manually.**

âœ” **Classes (`class` and `extends`) provide a structured way to use prototype inheritance.**

---

### **9ï¸âƒ£ Interview Tip ğŸ“**

ğŸ“ **One-Liner Answer:**

*"JavaScriptâ€™s prototype chain allows objects to inherit properties and methods by searching their prototype hierarchy, enabling code reusability and efficiency."*

ğŸ’¡ **Bonus Interview Question:**

âœ… **Q:** What happens if two objects in a prototype chain have the same property?

**A:** JavaScript returns the first found property. The search **stops** at the first match in the prototype chain.



### âœ… **Q4: What is the Difference Between `Object.create()` and Class-Based Inheritance?**

---

## **1ï¸âƒ£ Overview**

Both `Object.create()` and class-based inheritance allow objects to inherit properties and methods from other objects, but they work in  **different ways** .

| Feature                   | `Object.create()`                                    | Class-Based Inheritance (`class`)                 |
| ------------------------- | ------------------------------------------------------ | --------------------------------------------------- |
| **How it works**    | Creates a new object with a specified prototype        | Defines a class and creates instances using `new` |
| **Prototype chain** | Directly sets prototype manually                       | Uses `extends`to establish prototype hierarchy    |
| **Flexibility**     | More flexible; can create prototype chains dynamically | More structured and readable                        |
| **Performance**     | Slightly faster for prototype inheritance              | More optimized for object instantiation             |

---

## **2ï¸âƒ£ `Object.create()` â€“ Prototype-Based Inheritance**

ğŸ”¹ **`Object.create(proto)`** creates a new object with `proto` as its prototype.

ğŸ”¹ Used for **prototypal inheritance** without using classes.

### **Example: Creating an Object with `Object.create()`**

```js
const animal = {
  speak: function() {
    console.log(this.name + " makes a sound.");
  }
};

const dog = Object.create(animal); // dog inherits from animal
dog.name = "Buddy";

dog.speak(); // Output: Buddy makes a sound.
```

âœ… **Prototype Chain:** `dog â†’ animal â†’ Object.prototype â†’ null`

---

## **3ï¸âƒ£ Class-Based Inheritance (ES6 `class`)**

ğŸ”¹ Introduced in  **ES6 (`ECMAScript 2015`)** .

ğŸ”¹ Uses the `class` keyword for defining  **structured, OOP-style inheritance** .

### **Example: Class-Based Inheritance**

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + " makes a sound.");
  }
}

class Dog extends Animal {
  bark() {
    console.log(this.name + " barks!");
  }
}

const myDog = new Dog("Rex");

myDog.speak(); // Output: Rex makes a sound. (inherited from Animal)
myDog.bark();  // Output: Rex barks! (defined in Dog)
```

âœ… **Prototype Chain:** `myDog â†’ Dog.prototype â†’ Animal.prototype â†’ Object.prototype â†’ null`

---

## **4ï¸âƒ£ Key Differences Between `Object.create()` and Classes**

### **1ï¸âƒ£ Structure & Readability**

* `Object.create()` is  **more flexible** , allowing objects to inherit from others without class syntax.
* `class` provides  **structured, readable, and maintainable code** , especially in larger projects.

### **2ï¸âƒ£ Performance**

* `Object.create()` is **slightly faster** since it directly links the prototype.
* `class` creates instances using a  **constructor function** , optimized for object instantiation.

### **3ï¸âƒ£ Dynamic vs. Fixed Inheritance**

* `Object.create()` allows **dynamic prototype assignment** at runtime.
* `class` uses **static inheritance** (prototype chain is set when the class is defined).

### **4ï¸âƒ£ Multiple Inheritance**

* `Object.create()` allows **multiple prototypes** using  **mixins** .
* `class` supports **single inheritance** (one prototype chain).

---

## **5ï¸âƒ£ When to Use What?**

| Use Case                                  | Recommended Approach |
| ----------------------------------------- | -------------------- |
| Simple object inheritance                 | `Object.create()`  |
| Dynamic prototype assignment              | `Object.create()`  |
| Structured & scalable applications        | `class`            |
| OOP-style coding (readable, maintainable) | `class`            |
| Multiple inheritance (mixins)             | `Object.create()`  |

---

## **6ï¸âƒ£ Interview Tip ğŸ“**

ğŸ“ **One-Liner Answer:**

*"`Object.create()` provides flexible prototype-based inheritance, while `class` offers structured, object-oriented inheritance with better readability and maintainability."*

ğŸ’¡ **Bonus Interview Question:**

âœ… **Q:** Can you use `Object.create()` inside a class?

**A:** Yes! You can use `Object.create()` inside a class to dynamically assign a prototype.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
}

const dog = Object.create(new Animal("Buddy"));
console.log(dog.name); // Output: Buddy
```

---

ğŸš€ **Summary:**

* `Object.create()` â†’ Directly links objects via prototype inheritance.
* `class` â†’ Uses a constructor and prototype chain for structured inheritance.
* **Use `Object.create()` for dynamic inheritance and `class` for structured OOP code.

  **

### âœ… **Q5: What is the Difference Between `Object.freeze()` and `Object.seal()`?**

---

## **1ï¸âƒ£ Overview**

Both `Object.freeze()` and `Object.seal()` are used to **restrict modifications** to an object in JavaScript, but they work differently.

| Feature                       | `Object.freeze()`ğŸ”’   | `Object.seal()`ğŸ”     |
| ----------------------------- | ----------------------- | ----------------------- |
| **Adding properties**   | âŒ**Not allowed** | âŒ**Not allowed** |
| **Removing properties** | âŒ**Not allowed** | âŒ**Not allowed** |
| **Modifying values**    | âŒ**Not allowed** | âœ…**Allowed**     |
| **Changing prototype**  | âŒ**Not allowed** | âœ…**Allowed**     |
| **New properties**      | âŒ**Not allowed** | âŒ**Not allowed** |

---

## **2ï¸âƒ£ `Object.freeze()` â€“ Completely Immutable Object ğŸ”’**

* Prevents **modification, addition, and deletion** of properties.
* Properties and values  **cannot be changed** .
* Strictest way to make an object  **immutable** .

### **Example of `Object.freeze()`**

```js
const user = {
  name: "Alice",
  age: 25
};

Object.freeze(user);

user.age = 30;  // âŒ No effect (value won't change)
user.city = "New York";  // âŒ No effect (new property won't be added)
delete user.name;  // âŒ No effect (property won't be deleted)

console.log(user); // Output: { name: "Alice", age: 25 }
```

âœ… **Use `Object.freeze()` when you need a fully immutable object.**

---

## **3ï¸âƒ£ `Object.seal()` â€“ Allows Modification but No Add/Delete ğŸ”**

* **Values of existing properties can be modified** .
* **New properties cannot be added** .
* **Existing properties cannot be deleted** .
* The object  **remains extensible** .

### **Example of `Object.seal()`**

```js
const user = {
  name: "Alice",
  age: 25
};

Object.seal(user);

user.age = 30;  // âœ… Allowed (modification works)
user.city = "New York";  // âŒ No effect (new property won't be added)
delete user.name;  // âŒ No effect (property won't be deleted)

console.log(user); // Output: { name: "Alice", age: 30 }
```

âœ… **Use `Object.seal()` when you want to allow modifications but prevent structure changes.**

---

## **4ï¸âƒ£ Key Differences Between `Object.freeze()` & `Object.seal()`**

| Feature                           | `Object.freeze()`ğŸ”’ | `Object.seal()`ğŸ” |
| --------------------------------- | --------------------- | ------------------- |
| **Can modify values?**      | âŒ No                 | âœ… Yes              |
| **Can delete properties?**  | âŒ No                 | âŒ No               |
| **Can add new properties?** | âŒ No                 | âŒ No               |
| **Can change prototype?**   | âŒ No                 | âœ… Yes              |

---

## **5ï¸âƒ£ When to Use What?**

| Use Case                                                | Recommended Approach |
| ------------------------------------------------------- | -------------------- |
| Need a fully immutable object (constant values)         | `Object.freeze()`  |
| Allow modifications but prevent structural changes      | `Object.seal()`    |
| Security-sensitive data that must not change            | `Object.freeze()`  |
| Prevent unintended property deletions but allow updates | `Object.seal()`    |

---

## **6ï¸âƒ£ Interview Tip ğŸ“**

ğŸ“ **One-Liner Answer:**

*"Use `Object.freeze()` to make an object completely immutable, while `Object.seal()` allows modifications but prevents adding or deleting properties."*

ğŸ’¡ **Bonus Interview Question:**

âœ… **Q:** How can you check if an object is frozen or sealed?

**A:** Use `Object.isFrozen(obj)` and `Object.isSealed(obj)`.

```js
const obj = { key: "value" };
Object.freeze(obj);

console.log(Object.isFrozen(obj)); // âœ… true
console.log(Object.isSealed(obj)); // âœ… true (Sealed objects are also frozen)
```

---

ğŸš€ **Summary:**

* `Object.freeze()` â†’ **Fully immutable** (no changes allowed).
* `Object.seal()` â†’  **Modifiable values, but no add/delete of properties** .
* **Use `Object.freeze()` for constants & security, and `Object.seal()` for controlled modifications.**
