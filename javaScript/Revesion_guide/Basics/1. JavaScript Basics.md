# **JavaScript Basics - Interview Revision Guide** üöÄ

## **1. What is JavaScript?**

‚úÖ JavaScript is a **high-level, interpreted programming language** used for  **web development** .

‚úÖ It is  **single-threaded** ,  **dynamically typed** , and follows the **ECMAScript** standard.

‚úÖ It enables  **client-side scripting** ,  **server-side development (Node.js)** , and  **event-driven programming** .

---

## **2. JavaScript Data Types**

### **1Ô∏è‚É£ Primitive Data Types (Immutable & Stored in Stack)**

‚úî **Number** ‚Üí `let x = 10;`

‚úî **String** ‚Üí `let name = "Sayanta";`

‚úî **Boolean** ‚Üí `let isReady = true;`

‚úî **Undefined** ‚Üí `let x;`

‚úî **Null** ‚Üí `let y = null;`

‚úî **Symbol (ES6)** ‚Üí `let sym = Symbol("id");`

‚úî **BigInt (ES11)** ‚Üí `let big = 9007199254740991n;`

### **2Ô∏è‚É£ Non-Primitive Data Types (Mutable & Stored in Heap)**

‚úî **Object** ‚Üí `let obj = { name: "Sayanta", age: 25 };`

‚úî **Array** ‚Üí `let arr = [1, 2, 3];`

‚úî **Function** ‚Üí `function greet() { return "Hello"; }`

---

## **3. Variables & Scope**

### **1Ô∏è‚É£ Variable Declaration Methods**

| **Keyword** | **Scope** | **Reassignment** | **Hoisting**              |
| ----------------- | --------------- | ---------------------- | ------------------------------- |
| `var`           | Function Scope  | ‚úÖ Allowed             | ‚úÖ Hoisted (with `undefined`) |
| `let`           | Block Scope     | ‚úÖ Allowed             | ‚ùå Not hoisted                  |
| `const`         | Block Scope     | ‚ùå Not allowed         | ‚ùå Not hoisted                  |

üîπ **Example:**

```js
var a = 10; // Function-scoped
let b = 20; // Block-scoped
const c = 30; // Constant variable
```

---

## **4. Operators in JavaScript**

### **1Ô∏è‚É£ Arithmetic Operators**

‚úî `+` (Addition), `-` (Subtraction), `*` (Multiplication), `/` (Division), `%` (Modulus), `**` (Exponentiation)

### **2Ô∏è‚É£ Comparison Operators**

‚úî `==` (Equality, type-coercion)

‚úî `===` (Strict Equality, no type-coercion)

‚úî `!=`, `!==` (Not equal, Strict Not equal)

‚úî `>`, `<`, `>=`, `<=` (Greater/Less than)

üîπ **Example:**

```js
console.log(5 == "5"); // true (Type Coercion)
console.log(5 === "5"); // false (Strict Type Check)
```

### **3Ô∏è‚É£ Logical Operators**

‚úî `&&` (AND), `||` (OR), `!` (NOT)

üîπ **Example:**

```js
let x = true, y = false;
console.log(x && y); // false
console.log(x || y); // true
```

---

## **5. Functions in JavaScript**

### **1Ô∏è‚É£ Function Declaration (Hoisted)**

```js
function greet() {
    return "Hello, World!";
}
console.log(greet()); // ‚úÖ Works
```

### **2Ô∏è‚É£ Function Expression (Not Hoisted)**

```js
const greet = function() {
    return "Hello!";
};
console.log(greet()); // ‚úÖ Works
```

### **3Ô∏è‚É£ Arrow Functions (ES6, No `this` Binding)**

```js
const greet = () => "Hello!";
console.log(greet());
```

---

## **6. Loops & Iteration**

### **1Ô∏è‚É£ For Loop**

```js
for (let i = 0; i < 5; i++) {
    console.log(i);
}
```

### **2Ô∏è‚É£ While Loop**

```js
let i = 0;
while (i < 5) {
    console.log(i);
    i++;
}
```

### **3Ô∏è‚É£ ForEach (Array Iteration)**

```js
let arr = [1, 2, 3];
arr.forEach(num => console.log(num));
```

---

## **7. JavaScript Objects**

### **1Ô∏è‚É£ Object Creation**

```js
const person = {
    name: "Sayanta",
    age: 25,
    greet: function() {
        return `Hello, ${this.name}!`;
    }
};
console.log(person.greet()); // "Hello, Sayanta!"
```

### **2Ô∏è‚É£ Object Destructuring**

```js
const { name, age } = person;
console.log(name, age); // Sayanta 25
```

---

## **8. JavaScript Arrays**

### **1Ô∏è‚É£ Array Methods**

| **Method** | **Description**             |
| ---------------- | --------------------------------- |
| `push()`       | Adds item to end                  |
| `pop()`        | Removes last item                 |
| `shift()`      | Removes first item                |
| `unshift()`    | Adds item to start                |
| `map()`        | Returns a new array               |
| `filter()`     | Filters values based on condition |
| `reduce()`     | Reduces array to a single value   |
| `find()`       | Finds first matching element      |

üîπ **Example:**

```js
let nums = [1, 2, 3, 4];
let squared = nums.map(num => num * num);
console.log(squared); // [1, 4, 9, 16]
```

---

## **9. Asynchronous JavaScript (Callbacks, Promises, Async/Await)**

### **1Ô∏è‚É£ Callback Functions**

```js
function fetchData(callback) {
    setTimeout(() => {
        callback("Data received");
    }, 1000);
}
fetchData(data => console.log(data)); // Data received
```

### **2Ô∏è‚É£ Promises**

```js
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Data received"), 1000);
});

fetchData.then(data => console.log(data));
```

### **3Ô∏è‚É£ Async/Await (ES8)**

```js
async function fetchData() {
    return "Data received";
}
fetchData().then(console.log);
```

---

## **10. JavaScript ES6+ Features**

| **Feature**        | **Example**                     |
| ------------------------ | ------------------------------------- |
| `let`&`const`        | `let x = 10; const y = 20;`         |
| Arrow Functions          | `const sum = (a, b) => a + b;`      |
| Template Literals        | ``Hello, ${name}!``                   |
| Destructuring            | `const { name } = person;`          |
| Spread Operator          | `const newArr = [...arr, 4, 5];`    |
| Default Parameters       | `function greet(name = "Guest") {}` |
| Optional Chaining (ES11) | `console.log(user?.address?.city);` |

---

## **11. JavaScript Interview Questions**

‚úÖ **Q1:** What is the difference between `var`, `let`, and `const`?

‚úÖ **Q2:** What is the difference between `==` and `===`?

‚úÖ **Q3:** What are higher-order functions?

‚úÖ **Q4:** What is event delegation?

‚úÖ **Q5:** Explain closures with an example.

‚úÖ **Q6:** How does JavaScript handle asynchronous operations?

‚úÖ **Q7:** What is the difference between `map()` and `forEach()`?

‚úÖ **Q8:** Explain the call stack in JavaScript.


### **‚úÖ Q1: What is the difference between `var`, `let`, and `const`?**

### **1Ô∏è‚É£ `var` (Function-scoped, Hoisted, Reassignable)**

‚úî  **Scope** : Function-scoped (accessible throughout the function).

‚úî  **Hoisting** : Hoisted to the top but initialized as `undefined`.

‚úî  **Re-declaration** : Allowed within the same scope.

‚úî  **Re-assignment** : Allowed.

‚úî  **Issues** : Causes bugs due to lack of block-scoping.

üîπ **Example:**

```js
function test() {
  console.log(a); // ‚úÖ undefined (hoisted)
  var a = 10;
  console.log(a); // ‚úÖ 10
}
test();
```

---

### **2Ô∏è‚É£ `let` (Block-scoped, Hoisted, Mutable)**

‚úî  **Scope** : Block-scoped `{}` (only accessible within the block).

‚úî  **Hoisting** : Hoisted but **not initialized** (ReferenceError if accessed before declaration).

‚úî  **Re-declaration** : ‚ùå Not allowed within the same scope.

‚úî  **Re-assignment** : ‚úÖ Allowed.

üîπ **Example:**

```js
if (true) {
  let x = 5;
}
console.log(x); // ‚ùå ReferenceError: x is not defined
```

---

### **3Ô∏è‚É£ `const` (Block-scoped, Hoisted, Immutable)**

‚úî  **Scope** : Block-scoped `{}` like `let`.

‚úî  **Hoisting** : Hoisted but **not initialized** (ReferenceError if accessed before declaration).

‚úî  **Re-declaration** : ‚ùå Not allowed.

‚úî  **Re-assignment** : ‚ùå Not allowed (must be initialized at declaration).

üîπ **Example:**

```js
const y = 10;
y = 20; // ‚ùå TypeError: Assignment to constant variable.
```

---

### **4Ô∏è‚É£ Key Differences Table**

| Feature        | `var`                  | `let`                   | `const`                 |
| -------------- | ------------------------ | ------------------------- | ------------------------- |
| Scope          | Function-scoped          | Block-scoped              | Block-scoped              |
| Hoisting       | Hoisted as `undefined` | Hoisted (not initialized) | Hoisted (not initialized) |
| Re-declaration | ‚úÖ Allowed               | ‚ùå Not allowed            | ‚ùå Not allowed            |
| Re-assignment  | ‚úÖ Allowed               | ‚úÖ Allowed                | ‚ùå Not allowed            |

---

### **5Ô∏è‚É£ When to Use What?**

‚úÖ Use `const` **by default** for immutable values.

‚úÖ Use `let` when you  **need to reassign values** .

‚úÖ Avoid `var` in modern JavaScript (use `let` or `const`).

---

üîπ **Interview Tip:**

Always mention **scope, hoisting, re-declaration, and re-assignment** while answering this question. üöÄ



### ‚úÖ **Q2: What is the difference between `==` and `===`?**

| Operator | Name            | Type Conversion                     | Checks                                |
| -------- | --------------- | ----------------------------------- | ------------------------------------- |
| `==`   | Loose Equality  | ‚úÖ Converts types before comparison | Compares**values only**         |
| `===`  | Strict Equality | ‚ùå No type conversion               | Compares**both value and type** |

---

### **1Ô∏è‚É£ `==` (Loose Equality - Allows Type Coercion)**

‚úî Converts both values to a common type  **before comparing** .

‚úî May lead to unexpected results.

üîπ **Example:**

```js
console.log(5 == "5");   // ‚úÖ true (string "5" is converted to number 5)
console.log(0 == false); // ‚úÖ true (false is converted to 0)
console.log(null == undefined); // ‚úÖ true (both treated as no value)
```

---

### **2Ô∏è‚É£ `===` (Strict Equality - No Type Conversion)**

‚úî **Does not** convert types, it  **compares both value and type** .

‚úî Safer and recommended for most cases.

üîπ **Example:**

```js
console.log(5 === "5");   // ‚ùå false (number !== string)
console.log(0 === false); // ‚ùå false (boolean !== number)
console.log(null === undefined); // ‚ùå false (different types)
```

---

### **3Ô∏è‚É£ Key Differences Table**

| Comparison            | `==`(Loose Equality)      | `===`(Strict Equality)      |
| --------------------- | --------------------------- | ----------------------------- |
| `"5" == 5`          | ‚úÖ true (Type conversion)   | ‚ùå false (Different types)    |
| `0 == false`        | ‚úÖ true (false ‚Üí 0)        | ‚ùå false (boolean !== number) |
| `null == undefined` | ‚úÖ true                     | ‚ùå false                      |
| `[] == false`       | ‚úÖ true (`[] ‚Üí "" ‚Üí 0`) | ‚ùå false                      |

---

### **4Ô∏è‚É£ When to Use What?**

‚úÖ Use `===` **by default** to avoid unexpected behavior.

‚úÖ Use `==`  **only when you intentionally want type coercion** .

---

### **5Ô∏è‚É£ Interview Tip**

* Always mention **type coercion** in `==`.
* Show practical **examples** of why `===` is safer.
* If asked, explain **edge cases** like `null == undefined` (true) but `null === undefined` (false). üöÄ

### ‚úÖ **Q3: What are Higher-Order Functions?**

### **1Ô∏è‚É£ Definition**

A **Higher-Order Function (HOF)** is a function that  **either** :

‚úî Takes another function as an argument  **(callback function)** .

‚úî Returns a function as a result.

üìå  **Functions in JavaScript are first-class citizens** , meaning they can be assigned to variables, passed as arguments, and returned from other functions.

---

### **2Ô∏è‚É£ Example: HOF Taking a Function as an Argument**

üîπ **Example: `map()`** (applies a function to each array element)

```js
const numbers = [1, 2, 3, 4];

// map() takes a function as an argument
const doubled = numbers.map(num => num * 2);
console.log(doubled); // ‚úÖ [2, 4, 6, 8]
```

---

### **3Ô∏è‚É£ Example: HOF Returning a Function**

üîπ **Example: Function that returns another function**

```js
function greet(language) {
  return function(name) {
    if (language === "en") return `Hello, ${name}!`;
    if (language === "es") return `Hola, ${name}!`;
    return `Hi, ${name}!`;
  };
}

const englishGreet = greet("en");
console.log(englishGreet("Sayanta")); // ‚úÖ Hello, Sayanta!
```

---

### **4Ô∏è‚É£ Common Built-in Higher-Order Functions**

‚úî **`map()`** ‚Üí Transforms each element in an array.

‚úî **`filter()`** ‚Üí Returns elements that pass a condition.

‚úî **`reduce()`** ‚Üí Accumulates values into a single result.

‚úî **`forEach()`** ‚Üí Iterates over elements (does not return).

‚úî **`sort()`** ‚Üí Sorts elements based on a comparison function.

üîπ **Example: `filter()`**

```js
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // ‚úÖ [2, 4]
```

---

### **5Ô∏è‚É£ Key Benefits of Higher-Order Functions**

‚úÖ **Reusability** ‚Üí Avoids repetition by passing functions dynamically.

‚úÖ **Cleaner Code** ‚Üí Improves readability and reduces boilerplate.

‚úÖ **Functional Programming** ‚Üí Makes JavaScript more declarative.

---

### **6Ô∏è‚É£ Interview Tip**

* Define **HOFs** clearly: **"A function that takes another function as an argument OR returns a function."**
* Give practical examples (`map`, `filter`, `reduce`).
* Explain **why HOFs are useful** (reusability, cleaner code). üöÄ

### ‚úÖ **Q4: What is Event Delegation?**

### **1Ô∏è‚É£ Definition**

**Event Delegation** is a technique in JavaScript where a **single parent element** handles events for multiple child elements  **using event bubbling** .

üìå Instead of adding event listeners to each child element, you **attach one listener** to a common ancestor and use `event.target` to determine which child triggered the event.

---

### **2Ô∏è‚É£ How Does It Work?**

* Events in JavaScript **bubble up** from the target element to its ancestors.
* By adding a **single event listener** on a parent, you can manage events for all present & future child elements dynamically.

---

### **3Ô∏è‚É£ Example: Without Event Delegation (Inefficient)**

‚ùå Adding event listeners to each button separately:

```js
const buttons = document.querySelectorAll(".btn");

buttons.forEach(button => {
  button.addEventListener("click", () => {
    console.log("Button clicked:", button.textContent);
  });
});
```

‚ö† **Problems:**

* If new buttons are added dynamically, they won‚Äôt have event listeners.
* More memory usage due to multiple listeners.

---

### **4Ô∏è‚É£ Example: With Event Delegation (Efficient)**

‚úÖ Using a **single event listener** on a parent:

```js
document.querySelector("#buttonContainer").addEventListener("click", function(event) {
  if (event.target.classList.contains("btn")) {
    console.log("Button clicked:", event.target.textContent);
  }
});
```

üìå **How It Works?**

* The event listener is added to `#buttonContainer` (parent).
* When a button inside it is clicked, the event  **bubbles up** .
* `event.target` tells  **which button was clicked** , ensuring dynamic handling.

---

### **5Ô∏è‚É£ Benefits of Event Delegation**

‚úÖ **Better Performance** ‚Üí Uses fewer event listeners.

‚úÖ **Handles Dynamic Elements** ‚Üí Works even if new elements are added later.

‚úÖ **Simplifies Code** ‚Üí No need to manually attach/remove listeners for each child.

---

### **6Ô∏è‚É£ When to Use Event Delegation?**

‚úî Handling  **lists, tables, menus, or dynamically created elements** .

‚úî Handling  **form validation** , e.g., delegating `input` events on a form.

‚úî Handling **drag-and-drop events** efficiently.

---

### **7Ô∏è‚É£ Interview Tip**

* Define event delegation  **clearly** : *"A technique where a single event listener is added to a parent, leveraging event bubbling to manage multiple child elements."*
* Explain **why it's useful** (performance, dynamic elements).
* Give an **example** and discuss `event.target`. üöÄ

### ‚úÖ **Q5: Explain Closures with an Example.**

### **1Ô∏è‚É£ Definition**

A **closure** in JavaScript is a function that **remembers** the variables from its **outer scope** even after the outer function has finished executing.

üìå **Closures allow functions to "remember" variables from their lexical scope** even when executed outside that scope.

---

### **2Ô∏è‚É£ Example of a Closure**

```js
function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log(`Outer: ${outerVariable}, Inner: ${innerVariable}`);
  };
}

const closureInstance = outerFunction("Hello"); // ‚úÖ outerFunction executes, but its scope remains
closureInstance("World"); // ‚úÖ Outer: Hello, Inner: World
```

üìå **How It Works?**

* `innerFunction` **remembers** `outerVariable` even after `outerFunction` has executed.
* This is because `innerFunction` **forms a closure** over `outerFunction`'s scope.

---

### **3Ô∏è‚É£ Practical Uses of Closures**

‚úî **Data Encapsulation (Private Variables)**

Closures can be used to create **private variables** that can‚Äôt be accessed directly.

```js
function counter() {
  let count = 0; // Private variable
  return {
    increment: function() {
      count++;
      console.log("Count:", count);
    },
    decrement: function() {
      count--;
      console.log("Count:", count);
    }
  };
}

const myCounter = counter();
myCounter.increment(); // ‚úÖ Count: 1
myCounter.increment(); // ‚úÖ Count: 2
myCounter.decrement(); // ‚úÖ Count: 1
```

üìå **Why?**

* `count` is  **not accessible directly** , but can be modified using `increment()` and `decrement()`.
* This prevents unwanted modifications to `count`.

---

### **4Ô∏è‚É£ Closures in Asynchronous Code**

Closures are often used in **setTimeout()** to retain values:

```js
function delayedMessage(message, delay) {
  setTimeout(() => {
    console.log("Message:", message);
  }, delay);
}

delayedMessage("Hello, after 2s!", 2000); // ‚úÖ Message: Hello, after 2s!
```

üìå **How It Works?**

* The arrow function inside `setTimeout` **remembers** `message` even after `delayedMessage` has finished execution.

---

### **5Ô∏è‚É£ Key Benefits of Closures**

‚úÖ **Data Privacy** ‚Üí Helps create private variables.

‚úÖ **State Management** ‚Üí Retains data between function calls.

‚úÖ **Efficient Memory Use** ‚Üí Reduces global variables.

‚úÖ  **Useful in Callbacks & Asynchronous Code** .

---

### **6Ô∏è‚É£ Interview Tip**

* Define  **closure clearly** : *"A function that remembers its outer scope variables even after the outer function has executed."*
* Show a **simple example** (`outerFunction ‚Üí innerFunction`).
* Explain **real-world uses** (private variables, async functions). üöÄ

### ‚úÖ **Q6: How Does JavaScript Handle Asynchronous Operations?**

### **1Ô∏è‚É£ JavaScript is Single-Threaded but Asynchronous**

* JavaScript runs on a **single-threaded** event loop, meaning it executes  **one operation at a time** .
* However, it can handle **asynchronous operations** using the  **Event Loop** ,  **Callbacks** ,  **Promises** , and  **Async/Await** .

---

### **2Ô∏è‚É£ Key Asynchronous Mechanisms in JavaScript**

#### **üîπ (1) Callbacks (Traditional Method)**

A **callback function** is passed as an argument and executed once an operation is complete.

```js
function fetchData(callback) {
  setTimeout(() => {
    console.log("Data fetched!");
    callback();
  }, 2000);
}

fetchData(() => console.log("Callback executed!"));
```

‚úÖ  **Issue** : Leads to **"Callback Hell"** when multiple nested callbacks are used.

---

#### **üîπ (2) Promises (Modern Approach)**

A **Promise** represents a value that will be available in the future.

It has  **3 states** : `pending`, `resolved` (fulfilled), or `rejected`.

```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Data fetched successfully!");
    }, 2000);
  });
}

fetchData()
  .then((data) => console.log(data)) // ‚úÖ Success
  .catch((error) => console.log(error)); // ‚ùå Error Handling
```

‚úÖ **Solves "Callback Hell"** by making code more readable.

---

#### **üîπ (3) Async/Await (Syntactic Sugar for Promises)**

**Async/Await** makes asynchronous code look synchronous.

```js
async function fetchData() {
  try {
    let response = await new Promise((resolve) =>
      setTimeout(() => resolve("Data fetched!"), 2000)
    );
    console.log(response);
  } catch (error) {
    console.log("Error:", error);
  }
}

fetchData();
```

‚úÖ  **Benefits** :

* Improves **readability** by avoiding `.then()` chains.
* Easier **error handling** using `try-catch`.

---

### **3Ô∏è‚É£ The Event Loop & Concurrency**

JavaScript uses an **Event Loop** to handle async operations **without blocking** the main thread.

üìå **How it works?**

1. JS executes **synchronous** code first (Call Stack).
2. **Async operations** (Timers, Promises, etc.) go to Web APIs.
3. Once complete, callbacks move to  **Task Queue (for callbacks) or Microtask Queue (for Promises)** .
4. Event Loop checks if the **Call Stack is empty** ‚Üí Executes pending tasks.

---

### **4Ô∏è‚É£ Interview Tip**

* Explain **why JavaScript needs async handling** (single-threaded).
* Discuss  **callbacks, promises, async/await** .
* Mention  **event loop, task queue, and microtask queue** . üöÄ

### ‚úÖ **Q7: What is the difference between `map()` and `forEach()`?**

| Feature                | `map()`                                               | `forEach()`                                          |
| ---------------------- | ------------------------------------------------------- | ------------------------------------------------------ |
| **Return Value** | Returns a**new array**with transformed elements.  | Returns `undefined`(does not return a new array).    |
| **Modification** | Does**not modify**the original array.             | Modifies the original array (if elements are changed). |
| **Chaining**     | Supports method chaining (`map().filter().reduce()`). | Does**not**support chaining directly.            |
| **Performance**  | More efficient if transformation is needed.             | More efficient for simple iteration.                   |

---

### **1Ô∏è‚É£ Example: `map()` (Creates a New Array)**

```js
const numbers = [1, 2, 3, 4];

const doubled = numbers.map(num => num * 2);
console.log(doubled); // ‚úÖ [2, 4, 6, 8]
console.log(numbers); // ‚úÖ [1, 2, 3, 4] (Original array remains unchanged)
```

‚úÖ **Used When?**

* When you want to create a  **new transformed array** .

---

### **2Ô∏è‚É£ Example: `forEach()` (Iterates but Doesn't Return an Array)**

```js
const numbers = [1, 2, 3, 4];

numbers.forEach((num, index) => {
  numbers[index] = num * 2;
});

console.log(numbers); // ‚úÖ [2, 4, 6, 8] (Original array is modified)
```

‚úÖ **Used When?**

* When performing **side effects** like logging, modifying elements, etc.

---

### **3Ô∏è‚É£ Key Takeaways**

‚úî Use `map()` when you  **need a new transformed array** .

‚úî Use `forEach()` when you  **just want to loop through the array** .

---

### **4Ô∏è‚É£ Interview Tip**

* Start with a **table comparison** üìù.
* Explain **use cases** and **performance implications** üöÄ.

### ‚úÖ **Q8: Explain the Call Stack in JavaScript.**

### **1Ô∏è‚É£ What is the Call Stack?**

* The **call stack** is a **data structure** used by JavaScript to manage function execution.
* It follows the **LIFO (Last In, First Out)** principle.
* JavaScript is  **single-threaded** , meaning it executes  **one task at a time** , using the call stack.

---

### **2Ô∏è‚É£ How the Call Stack Works**

üìå **Step-by-step execution example:**

```js
function first() {
  console.log("First Function");
  second();
}

function second() {
  console.log("Second Function");
  third();
}

function third() {
  console.log("Third Function");
}

first();
```

üìå **Call Stack Execution:**

1Ô∏è‚É£ `first()` is pushed onto the stack.

2Ô∏è‚É£ `console.log("First Function")` executes.

3Ô∏è‚É£ `second()` is called ‚Üí pushed onto the stack.

4Ô∏è‚É£ `console.log("Second Function")` executes.

5Ô∏è‚É£ `third()` is called ‚Üí pushed onto the stack.

6Ô∏è‚É£ `console.log("Third Function")` executes.

7Ô∏è‚É£ `third()` finishes ‚Üí **popped off** the stack.

8Ô∏è‚É£ `second()` finishes ‚Üí **popped off** the stack.

9Ô∏è‚É£ `first()` finishes ‚Üí **popped off** the stack.

‚úÖ **Final Output:**

```
First Function
Second Function
Third Function
```

---

### **3Ô∏è‚É£ Call Stack Overflow (Error Example)**

üìå **If a function keeps calling itself indefinitely, the stack overflows:**

```js
function recursive() {
  console.log("Overflow?");
  recursive();
}

recursive(); // ‚ùå Uncaught RangeError: Maximum call stack size exceeded
```

* **Why?** The stack keeps pushing `recursive()` calls without popping them, leading to a  **stack overflow** .

---

### **4Ô∏è‚É£ Interview Tip**

‚úî Explain the **LIFO** principle.

‚úî Walk through an  **example with function calls** .

‚úî Mention **stack overflow issues** in recursion. üöÄ
