# **Fetch API & HTTP Requests - Interview Revision Guide** ğŸš€

## **1. What is the Fetch API?**

âœ” The **Fetch API** is a modern way to make HTTP requests in JavaScript.

âœ” It **replaces** `XMLHttpRequest (XHR)` and provides a **simpler, more readable** syntax.

âœ” It  **returns a Promise** , allowing us to handle asynchronous requests efficiently.

---

## **2. Basic Fetch Request**

Fetching data from an API (GET request):

```js
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json()) // Convert response to JSON
  .then(data => console.log(data)) // Handle data
  .catch(error => console.error("Error:", error)); // Handle errors
```

âœ… `fetch(url)` sends an HTTP request.

âœ… `.json()` parses the response body as JSON.

âœ… `.catch(error)` handles network errors.

---

## **3. Handling HTTP Methods (GET, POST, PUT, DELETE)**

### **1ï¸âƒ£ GET Request (Fetching Data)**

```js
fetch("https://jsonplaceholder.typicode.com/posts")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));
```

### **2ï¸âƒ£ POST Request (Sending Data)**

```js
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "New Post", body: "Content here", userId: 1 })
})
  .then(response => response.json())
  .then(data => console.log("Created:", data))
  .catch(error => console.error("Error:", error));
```

âœ… **`headers`** define content type.

âœ… **`body`** sends data as JSON.

### **3ï¸âƒ£ PUT Request (Updating Data)**

```js
fetch("https://jsonplaceholder.typicode.com/posts/1", {
  method: "PUT",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Updated Title", body: "Updated content" })
})
  .then(response => response.json())
  .then(data => console.log("Updated:", data))
  .catch(error => console.error("Error:", error));
```

âœ… PUT replaces the entire resource.

### **4ï¸âƒ£ DELETE Request (Removing Data)**

```js
fetch("https://jsonplaceholder.typicode.com/posts/1", {
  method: "DELETE"
})
  .then(response => console.log("Deleted successfully"))
  .catch(error => console.error("Error:", error));
```

âœ… DELETE removes the resource.

---

## **4. Handling Errors in Fetch API**

Fetch **only rejects** on  **network failure** , not on HTTP errors (like `404` or `500`).

We need to manually check `response.ok` for errors.

```js
fetch("https://jsonplaceholder.typicode.com/invalid-url")
  .then(response => {
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Fetch Error:", error.message));
```

âœ… `response.ok` is `false` for HTTP errors.

âœ… `response.status` provides the status code.

---

## **5. Using Fetch with Async/Await (Recommended)**

### **1ï¸âƒ£ Basic Async/Await Fetch**

```js
async function fetchData() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    if (!response.ok) throw new Error(`HTTP Error! Status: ${response.status}`);
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error.message);
  }
}
fetchData();
```

âœ… **More readable** than `.then()`.

âœ… Uses `try...catch` for better error handling.

### **2ï¸âƒ£ POST Request with Async/Await**

```js
async function createPost() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: "Async Post", body: "Content here", userId: 1 })
    });

    if (!response.ok) throw new Error(`HTTP Error! Status: ${response.status}`);
    let data = await response.json();
    console.log("Created:", data);
  } catch (error) {
    console.error("Error:", error.message);
  }
}
createPost();
```

âœ… `await` pauses execution until the request completes.

âœ… **`try...catch`** handles both network and HTTP errors.

---

## **6. Abort Fetch Requests (Avoid Memory Leaks)**

Use **AbortController** to  **cancel ongoing requests** .

```js
const controller = new AbortController();
const signal = controller.signal;

fetch("https://jsonplaceholder.typicode.com/posts", { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === "AbortError") {
      console.log("Fetch request was aborted!");
    } else {
      console.error("Fetch Error:", error.message);
    }
  });

// Abort the request before it completes
setTimeout(() => controller.abort(), 100);
```

âœ… Prevents unwanted requests from using resources.

âœ… **Useful in React when unmounting components.**

---

## **7. Handling Multiple Fetch Requests (Promise.all)**

When making multiple API calls, **`Promise.all()`** ensures all requests complete.

```js
Promise.all([
  fetch("https://jsonplaceholder.typicode.com/posts/1").then(res => res.json()),
  fetch("https://jsonplaceholder.typicode.com/users/1").then(res => res.json())
])
  .then(([post, user]) => {
    console.log("Post:", post);
    console.log("User:", user);
  })
  .catch(error => console.error("Error:", error));
```

âœ… Runs multiple requests  **in parallel** .

âœ… **Faster** than running requests sequentially.

---

## **8. Fetch API vs Axios**

| Feature                        | Fetch API                       | Axios                                     |
| ------------------------------ | ------------------------------- | ----------------------------------------- |
| **Syntax**               | Promise-based                   | Promise-based                             |
| **Error Handling**       | Only rejects on network failure | Rejects on HTTP errors too                |
| **Response Type**        | Needs `response.json()`       | Parses JSON automatically                 |
| **Request Cancellation** | Uses `AbortController`        | Uses `CancelToken`                      |
| **Interceptors**         | âŒ No built-in interceptors     | âœ… Supports request/response interceptors |

---

## **9. Interview Questions on Fetch API**

âœ… **Q1:** What is the Fetch API? How is it different from XHR?

âœ… **Q2:** What does `fetch()` return?

âœ… **Q3:** How do you handle errors in Fetch API?

âœ… **Q4:** How do you send a POST request using Fetch?

âœ… **Q5:** What is `async/await` and how does it improve Fetch requests?

âœ… **Q6:** How can you cancel an ongoing fetch request?

âœ… **Q7:** How do you fetch multiple APIs in parallel?

âœ… **Q8:** What is the difference between Fetch API and Axios?



### âœ… **Q1: What is the Fetch API? How is it different from XHR?**

---

## **1ï¸âƒ£ What is the Fetch API?**

The **Fetch API** is a modern JavaScript interface used to make HTTP requests (GET, POST, etc.).

It is  **promise-based** , making it easier to use than the older `XMLHttpRequest (XHR)`.

### **Example: Fetch API (Basic Usage)**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())  // Convert response to JSON
  .then(data => console.log(data))   // Handle the data
  .catch(error => console.error("Error:", error)); // Handle errors
```

âœ… **Key Features of Fetch API:**

* **Promise-based** (no need for callbacks).
* **Supports async/await** for cleaner code.
* **Works with modern JavaScript features like Streams and Service Workers** .
* **More readable syntax** than XHR.

---

## **2ï¸âƒ£ How is Fetch API Different from XHR?**

| Feature                              | Fetch API ğŸ†•                     | XHR (XMLHttpRequest) ğŸ†–          |
| ------------------------------------ | -------------------------------- | -------------------------------- |
| **Syntax**                     | Clean & readable (Promise-based) | Verbose & callback-based         |
| **Chaining**                   | `.then()`,`.catch()`         | Nested callbacks (callback hell) |
| **Async/Await Support**        | âœ… Yes                           | âŒ No                            |
| **Streaming Response**         | âœ… Yes (ReadableStream)          | âŒ No                            |
| **Error Handling**             | Only rejects on network failure  | Must manually check `status`   |
| **Supports JSON Parsing**      | âœ… Yes (`.json()`)             | âŒ No (manual `JSON.parse()`)  |
| **Works with Service Workers** | âœ… Yes                           | âŒ No                            |
| **CORS Handling**              | âœ… Yes (Built-in)                | âŒ More complex                  |

---

## **3ï¸âƒ£ Example: Fetch API vs XHR**

### **âœ… Fetch API (Modern Approach)**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())  
  .then(data => console.log(data))   
  .catch(error => console.error("Error:", error));
```

âœ… **Cleaner, readable, and uses Promises.**

---

### **âŒ XHR (Old Approach)**

```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);

xhr.onload = function () {
  if (xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));  
  } else {
    console.error("Error:", xhr.statusText);
  }
};

xhr.onerror = function () {
  console.error("Network Error");
};

xhr.send();
```

âŒ **More code, uses callbacks, and requires manual JSON parsing.**

---

## **4ï¸âƒ£ Using Async/Await with Fetch API**

### **Example: Fetch with Async/Await**

```javascript
async function getPost() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error);
  }
}

getPost();
```

âœ… **More readable and avoids `.then()` chaining.**

---

## **5ï¸âƒ£ When to Use XHR?**

Use XHR **only if you need to support very old browsers** (e.g., IE11). Otherwise,  **Fetch API is better in every way** .

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” **Fetch API** is modern, promise-based, and more readable than  **XHR** .

âœ” Fetch supports  **async/await** ,  **streaming** , and  **service workers** .

âœ” XHR requires  **manual error handling, callback nesting, and more code** .

âœ” **Always prefer Fetch API** unless supporting very old browsers.

ğŸš€ **Conclusion:** **Fetch API > XHR** in modern JavaScript. ğŸš€



### âœ… **Q2: What does `fetch()` return?**

---

## **1ï¸âƒ£ What is `fetch()`?**

The `fetch()` function is used to make HTTP requests in JavaScript. It **returns a Promise** that resolves to a  **Response object** .

### **Basic Example of `fetch()`**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => console.log(response))  
  .catch(error => console.error("Error:", error));
```

âœ… **Output (Response Object)**

```json
Response {
  "ok": true,
  "status": 200,
  "statusText": "OK",
  "headers": {},
  "url": "https://jsonplaceholder.typicode.com/posts/1",
  "body": ReadableStream,
  "bodyUsed": false
}
```

ğŸ‘‰ The **Response object** contains details like status, headers, and body.

---

## **2ï¸âƒ£ What Does `fetch()` Return?**

| Feature                   | What It Returns                                          |
| ------------------------- | -------------------------------------------------------- |
| **Returns**         | A `Promise`                                            |
| **Resolves to**     | A `Response`object                                     |
| **Contains**        | HTTP status, headers, and a `body`(stream)             |
| **Does Not Reject** | For HTTP errors (404, 500), it**resolves**normally |

---

## **3ï¸âƒ£ How to Read the Response Body?**

Since the response body is a  **stream** , you need to **convert it to a usable format** (`JSON`, `text`, `blob`, etc.).

### **âœ… Convert to JSON**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())  // Converts response to JSON
  .then(data => console.log(data))   // Prints JSON data
  .catch(error => console.error("Error:", error));
```

âœ… **Output (JSON Data)**

```json
{
  "userId": 1,
  "id": 1,
  "title": "Sample Title",
  "body": "Sample Content"
}
```

---

### **âœ… Convert to Text**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.text())  // Converts response to text
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));
```

---

### **âœ… Convert to Blob (For Images & Files)**

```javascript
fetch("https://example.com/image.jpg")
  .then(response => response.blob())  // Converts response to Blob
  .then(blob => console.log(blob))
  .catch(error => console.error("Error:", error));
```

---

## **4ï¸âƒ£ Does `fetch()` Reject on HTTP Errors (404, 500)?**

No âŒ, `fetch()`  **only rejects on network failures** , not HTTP errors.

```javascript
fetch("https://jsonplaceholder.typicode.com/invalid-url")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));  // Catches errors
```

âœ… **Fix: Use `response.ok` to check for HTTP errors.**

---

## **5ï¸âƒ£ Using `fetch()` with `async/await`**

```javascript
async function getData() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
  
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error);
  }
}

getData();
```

âœ… **More readable and avoids `.then()` chaining.**

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” `fetch()` **returns a Promise** that resolves to a  **Response object** .

âœ” The **Response object** contains `status`, `headers`, and a `body` (stream).

âœ” Use `.json()`, `.text()`, or `.blob()` to read the response.

âœ” **Fetch does NOT reject on HTTP errors** (e.g., 404, 500). Check `response.ok`.

âœ” **Always handle errors** using `.catch()` or `try...catch`.

ğŸš€ **Conclusion:** `fetch()` is powerful but requires proper response handling!



### âœ… **Q3: How do you handle errors in Fetch API?**

---

## **1ï¸âƒ£ Does `fetch()` Automatically Handle Errors?**

âŒ No, `fetch()`  **only rejects on network errors** , not HTTP errors (e.g., 404, 500).

âœ… You must **manually check** the response status.

---

## **2ï¸âƒ£ Common Types of Errors in `fetch()`**

| **Error Type**    | **When It Happens**                | **Does `fetch()`Reject?**  |
| ----------------------- | ---------------------------------------- | ---------------------------------- |
| **Network Error** | No internet, server down                 | âœ… Yes                             |
| **CORS Error**    | Cross-origin request blocked             | âœ… Yes                             |
| **Invalid JSON**  | API sends bad JSON                       | âŒ No (throws in `.json()`)      |
| **HTTP Errors**   | 404 Not Found, 500 Internal Server Error | âŒ No (must check `response.ok`) |

---

## **3ï¸âƒ£ Basic Error Handling in `fetch()`**

### **âœ… Handling HTTP Errors (404, 500)**

```javascript
fetch("https://jsonplaceholder.typicode.com/invalid-url")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Fetch error:", error));  // Handles errors
```

âœ… **Fix:** Use `response.ok` to check for HTTP errors.

---

## **4ï¸âƒ£ Handling Network Errors**

```javascript
fetch("https://invalid-url.com")
  .then(response => response.json())  
  .catch(error => console.error("Network error:", error));
```

âœ… **Catches cases like:**

* No internet
* Server down
* Domain doesnâ€™t exist

---

## **5ï¸âƒ£ Handling Invalid JSON Response**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json()) 
  .then(data => console.log(data))
  .catch(error => console.error("JSON Parsing Error:", error));
```

âœ… If the server  **sends bad JSON** , `.json()` will throw an error.

---

## **6ï¸âƒ£ Best Approach: Using `async/await` with `try...catch`**

```javascript
async function fetchData() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    let data = await response.json();
    console.log("Data received:", data);
  } catch (error) {
    console.error("Fetch Error:", error.message);
  }
}

fetchData();
```

âœ… **More readable than `.then()` chaining!**

âœ… **Handles all errors properly!**

---

## **7ï¸âƒ£ Handling Timeout Errors (Fetch Doesnâ€™t Support Timeout)**

```javascript
function fetchWithTimeout(url, timeout = 5000) {
  return Promise.race([
    fetch(url),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Request timeout!")), timeout)
    ),
  ]);
}

fetchWithTimeout("https://jsonplaceholder.typicode.com/posts/1", 3000)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));
```

âœ… **Fix:** Use `Promise.race()` to **reject the fetch request** if it takes too long.

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” **Always check `response.ok`** to handle HTTP errors (404, 500).

âœ” **Use `.catch()`** to handle **network errors** (e.g., no internet).

âœ” **Use `try...catch` with `async/await`** for better readability.

âœ”  **For timeouts** , use `Promise.race()`.

ğŸš€ **Conclusion:** Always handle fetch errors properly for a reliable app!



### âœ… **Q4: How do you send a POST request using Fetch?**

---

## **1ï¸âƒ£ What is a POST Request?**

A **POST request** is used to **send data** to a server (e.g., creating a new user, submitting a form).

**Key Differences from GET:**

| Feature             | GET                          | POST            |
| ------------------- | ---------------------------- | --------------- |
| **Data Sent** | In URL (query params)        | In request body |
| **Security**  | Less secure (exposed in URL) | More secure     |
| **Use Cases** | Fetching data                | Submitting data |

---

## **2ï¸âƒ£ Basic `fetch()` Syntax for a POST Request**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",  // ğŸ‘ˆ Specifies POST request
  headers: {
    "Content-Type": "application/json",  // ğŸ‘ˆ Tells the server we're sending JSON
  },
  body: JSON.stringify({
    title: "JavaScript Fetch",
    body: "This is a test post",
    userId: 1,
  }),
})
  .then(response => response.json()) // ğŸ‘ˆ Convert response to JSON
  .then(data => console.log("Success:", data)) // ğŸ‘ˆ Handle response data
  .catch(error => console.error("Error:", error)); // ğŸ‘ˆ Handle errors
```

âœ… **Fix:** Always set `Content-Type: application/json` when sending JSON.

âœ… **Fix:** Convert the `body` to a JSON string using `JSON.stringify()`.

---

## **3ï¸âƒ£ Using `async/await` for Better Readability**

```javascript
async function sendPostRequest() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        title: "Async/Await Example",
        body: "Using fetch with async/await",
        userId: 2,
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    let data = await response.json();
    console.log("Success:", data);
  } catch (error) {
    console.error("Error:", error.message);
  }
}

sendPostRequest();
```

âœ… **More readable than `.then()` chaining!**

âœ… **Proper error handling with `try...catch`!**

---

## **4ï¸âƒ£ Sending Form Data Instead of JSON**

Sometimes, you need to send **form data** (e.g., file uploads, form submissions).

### **ğŸ”¹ Using `FormData`**

```javascript
let formData = new FormData();
formData.append("username", "sayanta");
formData.append("email", "sayanta@example.com");

fetch("https://example.com/api/users", {
  method: "POST",
  body: formData, // ğŸ‘ˆ No need for JSON.stringify()
})
  .then(response => response.json())
  .then(data => console.log("Form submitted:", data))
  .catch(error => console.error("Error:", error));
```

âœ… **Fix:** Donâ€™t set `Content-Type` manually for `FormData`, `fetch()` handles it automatically.

---

## **5ï¸âƒ£ Sending a POST Request with Authentication (Bearer Token)**

```javascript
fetch("https://api.example.com/protected-data", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": "Bearer YOUR_ACCESS_TOKEN",  // ğŸ‘ˆ Sending auth token
  },
  body: JSON.stringify({ key: "value" }),
})
  .then(response => response.json())
  .then(data => console.log("Authenticated request success:", data))
  .catch(error => console.error("Error:", error));
```

âœ… **Fix:** Always send `Authorization: Bearer <TOKEN>` for secure APIs.

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” Use `method: "POST"` in `fetch()`.

âœ” Set `"Content-Type": "application/json"` in headers when sending JSON.

âœ” Convert the body to JSON using `JSON.stringify()`.

âœ” Use `async/await` for better readability.

âœ” Use `FormData` when sending files or form data.

âœ” Send authentication tokens in `Authorization` headers if required.

ğŸš€ **Conclusion:** Using `fetch()` for POST requests is easy and powerful!



### âœ… **Q5: What is `async/await` and how does it improve Fetch requests?**

---

## **1ï¸âƒ£ What is `async/await`?**

* `async/await` is a modern **ES2017+ feature** in JavaScript for handling asynchronous operations.
* It  **simplifies promise-based code** , making it look more like synchronous code.
* It helps avoid **callback hell** and  **`.then()` chaining** .

---

## **2ï¸âƒ£ How `async/await` Works**

* `async` before a function makes it return a  **Promise** .
* `await` pauses execution  **until the Promise resolves** .

### ğŸ”¹ **Example Without `async/await` (Using `.then()`)**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())
  .then(data => console.log("Post Title:", data.title))
  .catch(error => console.error("Error:", error));
```

ğŸ”´ **Problem:** Multiple `.then()` calls make it harder to read and debug.

---

## **3ï¸âƒ£ Fetch Requests Using `async/await`**

### âœ… **With `async/await`**

```javascript
async function fetchPost() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    let data = await response.json();
    console.log("Post Title:", data.title);
  } catch (error) {
    console.error("Error:", error.message);
  }
}

fetchPost();
```

âœ… **Fix:** No more `.then()` chaining.

âœ… **Fix:** Readable like synchronous code.

âœ… **Fix:** `try...catch` handles errors properly.

---

## **4ï¸âƒ£ Why `async/await` is Better for Fetch Requests**

| Feature                  | `.then()`                                   | `async/await`                          |
| ------------------------ | --------------------------------------------- | ---------------------------------------- |
| **Readability**    | Harder to read with multiple `.then()`calls | Clean & structured like synchronous code |
| **Error Handling** | Need `.catch()`separately                   | Uses `try...catch`for better control   |
| **Debugging**      | Difficult due to `.then()`nesting           | Easier, as errors are caught normally    |
| **Chaining**       | Becomes complex for multiple requests         | Simpler with multiple `await`calls     |

---

## **5ï¸âƒ£ Example: Fetching Multiple API Requests**

```javascript
async function fetchMultiplePosts() {
  try {
    let response1 = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    let data1 = await response1.json();

    let response2 = await fetch("https://jsonplaceholder.typicode.com/posts/2");
    let data2 = await response2.json();

    console.log("First Post:", data1.title);
    console.log("Second Post:", data2.title);
  } catch (error) {
    console.error("Error fetching posts:", error.message);
  }
}

fetchMultiplePosts();
```

âœ… **Fix:** No nested `.then()` calls.

âœ… **Fix:** Executes requests in sequence.

---

## **6ï¸âƒ£ Fetch with `async/await` and `Promise.all` (Parallel Requests)**

```javascript
async function fetchAllPosts() {
  try {
    let urls = [
      "https://jsonplaceholder.typicode.com/posts/1",
      "https://jsonplaceholder.typicode.com/posts/2",
    ];

    let responses = await Promise.all(urls.map(url => fetch(url)));
    let data = await Promise.all(responses.map(res => res.json()));

    console.log("Posts:", data);
  } catch (error) {
    console.error("Error fetching posts:", error.message);
  }
}

fetchAllPosts();
```

âœ… **Fix:** Uses `Promise.all()` to fetch multiple APIs  **in parallel** .

âœ… **Fix:** Faster than sequential `await` calls.

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” `async/await` makes asynchronous code easier to read and write.

âœ” Works with `fetch()` to remove `.then()` chaining.

âœ” Handles errors using `try...catch`.

âœ” Can be used with `Promise.all()` for parallel API calls.

ğŸš€ **Conclusion:** `async/await` makes Fetch requests more efficient and readable!



### âœ… **Q6: How can you cancel an ongoing fetch request?**

---

## **1ï¸âƒ£ Why Cancel a Fetch Request?**

Sometimes, you may need to cancel a fetch request, for example:

âœ” The user navigates away before the request completes.

âœ” A new request replaces an older one (e.g., live search suggestions).

âœ” To avoid unnecessary network usage.

---

## **2ï¸âƒ£ Using `AbortController` to Cancel Fetch Requests**

JavaScript provides the  **`AbortController` API** , which allows us to cancel a fetch request before it completes.

### ğŸ”¹ **Example: Cancelling a Fetch Request**

```javascript
const controller = new AbortController();
const signal = controller.signal;

async function fetchData() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1", { signal });

    let data = await response.json();
    console.log("Fetched Data:", data);
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("Fetch request was canceled!");
    } else {
      console.error("Fetch error:", error);
    }
  }
}

// Start the request
fetchData();

// Cancel the request after 2 seconds
setTimeout(() => controller.abort(), 2000);
```

âœ… **Fix:** Uses `AbortController` to cancel the request.

âœ… **Fix:** Handles the `"AbortError"` in `catch` to prevent unnecessary logs.

---

## **3ï¸âƒ£ Cancelling Fetch in Real-World Scenarios**

### **ğŸ”¹ Use Case: Canceling Previous Requests in Search Input**

When users type in a search box, we want to cancel previous fetch requests and only process the latest one.

```javascript
let controller;

async function search(query) {
  if (controller) {
    controller.abort(); // Cancel the previous request
  }

  controller = new AbortController();
  const signal = controller.signal;

  try {
    let response = await fetch(`https://api.example.com/search?q=${query}`, { signal });
    let data = await response.json();
    console.log("Search results:", data);
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("Previous search request canceled!");
    } else {
      console.error("Fetch error:", error);
    }
  }
}

// Simulating user typing
search("JavaScript");
setTimeout(() => search("JavaScript Fetch API"), 500); // Cancels previous request
```

âœ… **Fix:** Cancels previous search requests when the user types.

âœ… **Fix:** Prevents unnecessary network requests.

---

## **4ï¸âƒ£ Cancelling Multiple Fetch Requests**

If multiple fetch requests need to be canceled together,  **use a shared `AbortController`** .

```javascript
const controller = new AbortController();
const signal = controller.signal;

async function fetchUsers() {
  return fetch("https://jsonplaceholder.typicode.com/users", { signal });
}

async function fetchPosts() {
  return fetch("https://jsonplaceholder.typicode.com/posts", { signal });
}

// Start multiple fetch requests
fetchUsers();
fetchPosts();

// Cancel all requests after 3 seconds
setTimeout(() => controller.abort(), 3000);
```

âœ… **Fix:** Cancels multiple ongoing requests together.

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” Use **`AbortController`** to cancel fetch requests.

âœ” Attach **`signal`** to `fetch()` for controllable cancellation.

âœ” Handle the `"AbortError"` in `catch` to prevent unwanted logs.

âœ” Useful in  **search inputs** ,  **navigation changes** , and  **optimizing performance** .

ğŸš€ **Conclusion:** Cancelling fetch requests is essential for efficient network handling!



### âœ… **Q7: How do you fetch multiple APIs in parallel?**

---

## **1ï¸âƒ£ Why Fetch Multiple APIs in Parallel?**

Fetching multiple APIs in parallel improves performance by executing all requests simultaneously instead of waiting for one to finish before starting another.

ğŸ”¹ **Use Cases:**

âœ” Fetching **user details** and **user posts** at the same time.

âœ” Fetching **multiple endpoints** in a dashboard.

âœ” Fetching **data from different microservices** simultaneously.

---

## **2ï¸âƒ£ Using `Promise.all()` for Parallel Requests**

The **best way** to fetch multiple APIs in parallel is to use `Promise.all()`. It executes all promises together and waits for all of them to complete.

### **ğŸ”¹ Example: Fetching User Data and Posts Together**

```javascript
async function fetchUserData() {
  const userPromise = fetch("https://jsonplaceholder.typicode.com/users/1").then(res => res.json());
  const postsPromise = fetch("https://jsonplaceholder.typicode.com/posts?userId=1").then(res => res.json());

  try {
    const [user, posts] = await Promise.all([userPromise, postsPromise]);
    console.log("User Data:", user);
    console.log("User Posts:", posts);
  } catch (error) {
    console.error("Error fetching data:", error);
  }
}

fetchUserData();
```

âœ… **Fix:** Uses `Promise.all()` to run both fetches in parallel.

âœ… **Fix:** Improves performance by fetching both at the same time.

âœ… **Fix:** Handles errors properly using `try...catch`.

---

## **3ï¸âƒ£ Handling Errors in `Promise.all()`**

If  **one request fails** , `Promise.all()` **rejects all** promises. To handle errors separately, use `.catch()` on each promise.

### **ğŸ”¹ Example: Handling Errors Individually**

```javascript
async function fetchMultipleAPIs() {
  const userPromise = fetch("https://jsonplaceholder.typicode.com/users/1").then(res => res.json()).catch(err => console.error("User fetch failed:", err));
  const postsPromise = fetch("https://jsonplaceholder.typicode.com/posts?userId=1").then(res => res.json()).catch(err => console.error("Posts fetch failed:", err));

  const [user, posts] = await Promise.all([userPromise, postsPromise]);
  console.log("User:", user);
  console.log("Posts:", posts);
}

fetchMultipleAPIs();
```

âœ… **Fix:** Uses `.catch()` inside each promise to prevent total failure.

âœ… **Fix:** Ensures one failure doesnâ€™t stop other requests.

---

## **4ï¸âƒ£ Using `Promise.allSettled()` for Better Error Handling**

If we want  **all requests to complete** , even if some fail, use `Promise.allSettled()`.

### **ğŸ”¹ Example: Using `Promise.allSettled()`**

```javascript
async function fetchWithAllSettled() {
  const responses = await Promise.allSettled([
    fetch("https://jsonplaceholder.typicode.com/users/1").then(res => res.json()),
    fetch("https://jsonplaceholder.typicode.com/posts?userId=1").then(res => res.json()),
    fetch("https://jsonplaceholder.typicode.com/invalid-url").then(res => res.json()) // Invalid URL
  ]);

  responses.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`API ${index + 1} Success:`, result.value);
    } else {
      console.error(`API ${index + 1} Failed:`, result.reason);
    }
  });
}

fetchWithAllSettled();
```

âœ… **Fix:** Ensures all requests run, even if some fail.

âœ… **Fix:** Uses `status === "fulfilled"` to check success.

---

## **5ï¸âƒ£ Using `Promise.race()` for the Fastest Response**

If you want to  **fetch multiple APIs but only use the fastest response** , use `Promise.race()`.

### **ğŸ”¹ Example: Using `Promise.race()`**

```javascript
async function fetchFastestAPI() {
  try {
    const response = await Promise.race([
      fetch("https://jsonplaceholder.typicode.com/users/1").then(res => res.json()),
      fetch("https://jsonplaceholder.typicode.com/posts/1").then(res => res.json())
    ]);
    console.log("Fastest Response:", response);
  } catch (error) {
    console.error("Error:", error);
  }
}

fetchFastestAPI();
```

âœ… **Fix:** Returns only the  **fastest API response** .

âœ… **Fix:** Useful for **redundant API calls** where any response is acceptable.

---

## **ğŸ¯ Final Summary (For Interviews)**

âœ” **`Promise.all()`** â†’ Best for parallel API requests (Fast & efficient).

âœ” **`Promise.allSettled()`** â†’ Ensures all requests complete, even if some fail.

âœ” **`Promise.race()`** â†’ Returns only the fastest response.

âœ” **Handle errors properly** â†’ Use `try...catch` or `.catch()` inside individual promises.

ğŸš€ **Conclusion:** Parallel fetching improves performance and is essential for  **real-world applications** !



### âœ… **Q8: What is the difference between Fetch API and Axios?**

Both **Fetch API** and **Axios** are used to make HTTP requests in JavaScript, but they have key differences in syntax, features, and error handling.

---

## **1ï¸âƒ£ Fetch API vs. Axios: Quick Comparison**

| Feature                        | Fetch API (Built-in)        | Axios (3rd-Party Library)      |
| ------------------------------ | --------------------------- | ------------------------------ |
| **Ease of Use**          | More verbose                | Simpler syntax                 |
| **Error Handling**       | Requires manual checking    | Handles errors automatically   |
| **Response Parsing**     | Needs `.json()`conversion | Auto-converts JSON             |
| **Request Cancellation** | Uses `AbortController`    | Uses built-in `CancelToken`  |
| **Timeout Handling**     | Requires manual setup       | Built-in timeout support       |
| **Browser Support**      | Modern browsers only        | Works in older browsers too    |
| **Interceptors**         | Not available               | Available for request/response |

---

## **2ï¸âƒ£ Fetch API: How It Works**

Fetch is a built-in JavaScript function for making network requests.

### **ğŸ”¹ Example: Fetching Data with Fetch API**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Fetch Error:", error));
```

âœ…  **Requires explicit error handling (`if (!response.ok)`)** .

âœ… **Requires `.json()` conversion** to extract data.

---

## **3ï¸âƒ£ Axios: How It Works**

Axios is a third-party HTTP client that simplifies requests and responses.

### **ğŸ”¹ Example: Fetching Data with Axios**

```javascript
axios.get("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => console.log(response.data))
  .catch(error => console.error("Axios Error:", error));
```

âœ… **Automatically checks for errors** (no need for `if (!response.ok)`).

âœ… **Automatically parses JSON** (no need for `.json()`).

---

## **4ï¸âƒ£ Handling Errors: Fetch vs. Axios**

### **ğŸ”¹ Fetch API**

```javascript
fetch("https://jsonplaceholder.typicode.com/posts/invalid-url")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}`);
    }
    return response.json();
  })
  .catch(error => console.error("Fetch Error:", error));
```

âŒ Fetch **does not reject on HTTP errors** (e.g., 404 or 500).

âœ” You must manually check `response.ok`.

### **ğŸ”¹ Axios**

```javascript
axios.get("https://jsonplaceholder.typicode.com/posts/invalid-url")
  .then(response => console.log(response.data))
  .catch(error => console.error("Axios Error:", error));
```

âœ” Axios **automatically rejects** HTTP errors (no need for manual checks).

---

## **5ï¸âƒ£ Request Cancellation: Fetch vs. Axios**

### **ğŸ”¹ Using `AbortController` with Fetch**

```javascript
const controller = new AbortController();
const signal = controller.signal;

fetch("https://jsonplaceholder.typicode.com/posts", { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Fetch Error:", error));

// Cancel the request
controller.abort();
```

âœ… Fetch supports cancellation using `AbortController`, but it's  **not built-in** .

### **ğŸ”¹ Using Axios `CancelToken`**

```javascript
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get("https://jsonplaceholder.typicode.com/posts", { cancelToken: source.token })
  .then(response => console.log(response.data))
  .catch(error => console.error("Axios Error:", error));

// Cancel the request
source.cancel("Request canceled.");
```

âœ… Axios  **has built-in request cancellation** .

---

## **6ï¸âƒ£ Timeout Handling: Fetch vs. Axios**

### **ğŸ”¹ Fetch (Manual Timeout Handling)**

Fetch does **not** support timeouts natively. You must use `setTimeout()` manually.

```javascript
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000); // Timeout after 5 seconds

fetch("https://jsonplaceholder.typicode.com/posts", { signal: controller.signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Fetch Timeout Error:", error));
```

âŒ  **Fetch has no built-in timeout support** .

âœ” **You must manually abort requests** using `AbortController`.

### **ğŸ”¹ Axios (Built-in Timeout)**

Axios  **supports timeouts natively** .

```javascript
axios.get("https://jsonplaceholder.typicode.com/posts", { timeout: 5000 })
  .then(response => console.log(response.data))
  .catch(error => console.error("Axios Timeout Error:", error));
```

âœ…  **Axios has built-in timeout handling** .

---

## **7ï¸âƒ£ Request & Response Interceptors (Only in Axios)**

Axios allows you to **modify requests/responses globally** before they are sent or received.

### **ğŸ”¹ Axios Interceptors Example**

```javascript
axios.interceptors.request.use(config => {
  config.headers.Authorization = "Bearer my-token";
  console.log("Request Sent:", config);
  return config;
});

axios.interceptors.response.use(response => {
  console.log("Response Received:", response);
  return response;
});
```

âœ”  **Useful for adding authentication headers** .

âœ”  **Useful for logging API responses** .

âŒ  **Fetch API does not support interceptors** .

---

## **ğŸ¯ Final Summary (For Interviews)**

| Feature                        | Fetch API                       | Axios                           |
| ------------------------------ | ------------------------------- | ------------------------------- |
| **Built-in?**            | âœ… Yes (Native)                 | âŒ No (3rd Party)               |
| **Ease of Use**          | âŒ Verbose                      | âœ… Simple                       |
| **Error Handling**       | âŒ Needs manual check           | âœ… Automatic                    |
| **JSON Parsing**         | âŒ Needs `.json()`            | âœ… Automatic                    |
| **Request Cancellation** | âŒ Manual (`AbortController`) | âœ… Built-in (`CancelToken`)   |
| **Timeout Handling**     | âŒ Manual (`setTimeout`)      | âœ… Built-in (`timeout`option) |
| **Interceptors**         | âŒ No                           | âœ… Yes                          |
| **Browser Support**      | âœ… Modern Browsers              | âœ… Older Browsers Supported     |

ğŸš€ **Conclusion:**

âœ” Use **Fetch API** when you need a lightweight, built-in solution.

âœ” Use **Axios** when you need  **better error handling, automatic JSON parsing, request cancellation, and timeouts** .
