# **Event Loop & Concurrency - Interview Revision Guide** üöÄ

## **1. What is the Event Loop?**

‚úî **The Event Loop is the mechanism that allows JavaScript to be asynchronous, despite being single-threaded.**

‚úî It enables **non-blocking** operations like handling I/O, timers, and network requests.

‚úî JavaScript executes **synchronous** code first, then processes asynchronous callbacks from the  **callback queue** .

---

## **2. JavaScript Execution Model**

üü¢ **Single-threaded:** JavaScript has only **one main execution thread** (the Call Stack).

üü¢ **Asynchronous behavior** is managed by the Event Loop along with:

* Call Stack
* Web APIs
* Callback Queue
* Microtask Queue

---

## **3. How JavaScript Handles Concurrency?**

‚úî JavaScript is **not multi-threaded** but achieves concurrency through the  **Event Loop** .

‚úî The **Event Loop continuously checks** whether the Call Stack is empty before executing pending tasks from queues.

---

## **4. Understanding the Call Stack**

* The **Call Stack** stores function calls in a **LIFO (Last In, First Out)** order.
* When a function is executed, it gets pushed onto the  **Call Stack** .
* Once it completes, it is popped off the stack.
* If the stack is **blocked** by a long-running function, it  **delays other code execution** .

```js
function first() {
  console.log("First");
}
function second() {
  console.log("Second");
}
first();
second();
console.log("Third");
```

‚úÖ **Output:**

```
First  
Second  
Third  
```

‚úî Since JavaScript is  **synchronous by default** , it executes functions  **in order** .

---

## **5. Web APIs & Asynchronous Operations**

‚úî JavaScript uses **Web APIs** (provided by the browser) for handling async tasks like:

* `setTimeout()`
* `setInterval()`
* `fetch()` (AJAX/HTTP Requests)
* `DOM Events`

‚úî These tasks **don't block** the Call Stack but are sent to  **Web APIs** , and their callbacks are stored in the  **Callback Queue** .

```js
console.log("Start");

setTimeout(() => console.log("Inside setTimeout"), 0);

console.log("End");
```

‚úÖ **Output:**

```
Start  
End  
Inside setTimeout
```

‚úî `setTimeout` moves to the Web API, allowing synchronous code to execute first.

---

## **6. Callback Queue vs Microtask Queue**

‚úî **Callback Queue:** Stores tasks from Web APIs (e.g., `setTimeout`, `setInterval`).

‚úî **Microtask Queue:** Stores **higher-priority tasks** like:

* `Promise.then()`
* `MutationObserver`

‚úî **Microtasks always execute before Callbacks** if both are waiting.

```js
console.log("Start");

setTimeout(() => console.log("setTimeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```

‚úÖ **Output:**

```
Start  
End  
Promise  
setTimeout
```

‚úî Even though `setTimeout()` has  **0ms delay** , the `Promise.then()` executes **first** because the  **Microtask Queue has higher priority** .

---

## **7. Event Loop in Action**

‚úî The  **Event Loop continuously checks** :

1Ô∏è‚É£ **Is the Call Stack empty?**

2Ô∏è‚É£ **Are there tasks in the Microtask Queue?**

3Ô∏è‚É£ **Are there tasks in the Callback Queue?**

üëâ  **Microtasks run before Callbacks** , ensuring priority execution.

---

## **8. Interview Questions on Event Loop & Concurrency**

‚úÖ **Q1:** What is the Event Loop, and why is it important?

‚úÖ **Q2:** How does JavaScript handle asynchronous operations?

‚úÖ **Q3:** What is the difference between the Call Stack and Event Loop?

‚úÖ **Q4:** What is the difference between the Callback Queue and the Microtask Queue?

‚úÖ **Q5:** Why does `Promise.then()` execute before `setTimeout()`?

‚úÖ **Q6:** Explain how Web APIs work with the Event Loop.

‚úÖ **Q7:** What happens if an expensive operation blocks the Call Stack?


### ‚úÖ **Q1: What is the Event Loop, and why is it important?**

---

## **1Ô∏è‚É£ What is the Event Loop?**

üîπ The **event loop** is a mechanism in JavaScript that handles **asynchronous operations** by managing the execution of code, events, and tasks.

üîπ It allows JavaScript to be **non-blocking** and handle multiple tasks efficiently.

### **üìå Key Concept** :

JavaScript is  **single-threaded** , meaning it executes one task at a time.

However, with  **callbacks, promises, and async/await** , JavaScript can handle multiple operations using the  **event loop** .

---

## **2Ô∏è‚É£ How Does the Event Loop Work?**

### **üìå Execution Process:**

1Ô∏è‚É£ **Call Stack** ‚Üí Executes synchronous code (functions, variables, loops).

2Ô∏è‚É£ **Web APIs** ‚Üí Handles asynchronous tasks (setTimeout, fetch, DOM events).

3Ô∏è‚É£ **Callback Queue** ‚Üí Stores callbacks from async operations.

4Ô∏è‚É£ **Microtask Queue** ‚Üí Stores promises & `process.nextTick()` (executes before callbacks).

5Ô∏è‚É£ **Event Loop** ‚Üí Moves tasks from **queues** to **call stack** when it's empty.

---

## **3Ô∏è‚É£ Event Loop in Action (Example)**

```js
console.log("Start"); 

setTimeout(() => console.log("Timeout"), 0); 

Promise.resolve().then(() => console.log("Promise")); 

console.log("End"); 
```

### **üìå Execution Order:**

1Ô∏è‚É£ `"Start"` ‚Üí  **Synchronous** , executed immediately.

2Ô∏è‚É£ `"End"` ‚Üí  **Synchronous** , executed immediately.

3Ô∏è‚É£ `Promise.resolve().then(...)` ‚Üí Goes to  **Microtask Queue** .

4Ô∏è‚É£ `setTimeout(...)` ‚Üí Goes to  **Callback Queue** .

5Ô∏è‚É£ **Microtasks run first!** ‚Üí `"Promise"` logs.

6Ô∏è‚É£ **Event Loop moves callbacks to Call Stack** ‚Üí `"Timeout"` logs.

### **üìå Output:**

```
Start
End
Promise
Timeout
```

---

## **4Ô∏è‚É£ Why is the Event Loop Important?**

‚úÖ **Non-blocking Execution** ‚Üí Prevents JavaScript from freezing.

‚úÖ **Efficient Async Handling** ‚Üí Manages APIs, timers, and user interactions.

‚úÖ **Optimized Performance** ‚Üí Uses queues and microtasks to execute tasks quickly.

---

## **5Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"The event loop is a JavaScript mechanism that manages asynchronous operations by continuously checking the call stack and moving tasks from queues when the stack is empty."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** What is the difference between the Call Stack and Event Loop?

**A:** The Call Stack executes synchronous code, while the Event Loop manages asynchronous tasks.

2Ô∏è‚É£ **Q:** What executes first: setTimeout or a resolved Promise?

**A:** **Promise** executes first because Microtasks have higher priority than the Callback Queue.

3Ô∏è‚É£ **Q:** What is the difference between Macrotasks and Microtasks?

**A:** Microtasks (Promises, `queueMicrotask`) run **before** Macrotasks (setTimeout, setInterval).

üöÄ **Key Takeaway:**

The **event loop** makes JavaScript  **non-blocking** , handling async tasks efficiently!



### ‚úÖ **Q2: How does JavaScript handle asynchronous operations?**

---

## **1Ô∏è‚É£ What is Asynchronous JavaScript?**

üîπ JavaScript is **single-threaded** (executes one task at a time).

üîπ However, it supports **asynchronous operations** using **callbacks, promises, and async/await** to avoid blocking the main thread.

üìå **Example of an Asynchronous Operation:**

* Fetching data from an API
* Reading a file
* Timers (`setTimeout`, `setInterval`)
* Handling events (e.g., button clicks)

---

## **2Ô∏è‚É£ Mechanisms for Handling Async Operations**

### **üîπ 1. Callbacks (Old Approach)**

* A function passed as an argument to another function.
* Can lead to **callback hell** (nested callbacks that are hard to read).

```js
console.log("Start");

setTimeout(() => {
  console.log("Async operation completed");
}, 2000);

console.log("End");
```

üìå **Output:**

```
Start
End
Async operation completed
```

**(Main thread continues execution while waiting for the timer to complete.)**

---

### **üîπ 2. Promises (Modern Approach)**

* Introduced in ES6 to handle async operations better.
* Has  **three states** : `pending`, `resolved`, `rejected`.
* Uses `.then()` and `.catch()` for chaining.

```js
console.log("Start");

const fetchData = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Data fetched"), 2000);
});

fetchData.then((data) => console.log(data));

console.log("End");
```

üìå **Output:**

```
Start
End
Data fetched
```

‚úÖ **No callback hell, more readable!**

---

### **üîπ 3. Async/Await (Best Approach)**

* Introduced in ES8 (ES2017).
* Syntactic sugar over Promises for a cleaner, synchronous-looking structure.
* Uses `async` to define a function and `await` to pause execution until a Promise resolves.

```js
console.log("Start");

async function fetchData() {
  let result = await new Promise((resolve) => 
    setTimeout(() => resolve("Data fetched"), 2000)
  );
  console.log(result);
}

fetchData();

console.log("End");
```

üìå **Output:**

```
Start
End
Data fetched
```

‚úÖ **More readable than Promises!**

‚úÖ **Handles async code sequentially!**

---

## **3Ô∏è‚É£ Event Loop & Async Execution**

üìå JavaScript uses the **event loop** to handle asynchronous operations:

1Ô∏è‚É£ **Call Stack** ‚Üí Executes synchronous code.

2Ô∏è‚É£ **Web APIs** ‚Üí Handles async tasks like `setTimeout`, `fetch`.

3Ô∏è‚É£ **Callback & Microtask Queue** ‚Üí Stores async operations and resolves them when the stack is clear.

4Ô∏è‚É£ **Event Loop** ‚Üí Moves pending tasks to the call stack.

---

## **4Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"JavaScript handles asynchronous operations using the event loop and mechanisms like Callbacks, Promises, and Async/Await, ensuring non-blocking execution."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** What is the difference between Promises and Async/Await?

**A:** Promises use `.then()` for chaining, while Async/Await provides a cleaner, synchronous-like syntax.

2Ô∏è‚É£ **Q:** Why use Async/Await over Callbacks?

**A:** Callbacks lead to  **callback hell** , whereas Async/Await is more readable.

3Ô∏è‚É£ **Q:** What executes first: `setTimeout` or `Promise.resolve()`?

**A:** `Promise.resolve()` executes first because Promises are  **Microtasks** , and they have higher priority than Macrotasks (`setTimeout`).

üöÄ **Key Takeaway:**

JavaScript efficiently handles asynchronous operations using  **callbacks, promises, and async/await** , while the **event loop** ensures non-blocking execution.



### ‚úÖ **Q3: What is the difference between the Call Stack and Event Loop?**

---

## **1Ô∏è‚É£ What is the Call Stack?**

üìå **Definition:**

The **Call Stack** is a data structure that stores function calls in a **Last In, First Out (LIFO)** order.

üìå **How it works:**

1Ô∏è‚É£ When a function is invoked, it is **pushed** onto the Call Stack.

2Ô∏è‚É£ When the function finishes execution, it is **popped** from the stack.

3Ô∏è‚É£ The process continues until the stack is empty.

üìå **Example:**

```js
function first() {
  console.log("First");
  second();
}
function second() {
  console.log("Second");
  third();
}
function third() {
  console.log("Third");
}
first();
```

üìå **Call Stack Execution:**

1Ô∏è‚É£ `first()` ‚Üí Pushed onto the stack

2Ô∏è‚É£ `second()` ‚Üí Pushed onto the stack

3Ô∏è‚É£ `third()` ‚Üí Pushed onto the stack

4Ô∏è‚É£ `console.log("Third")` executes ‚Üí `third()` is popped

5Ô∏è‚É£ `console.log("Second")` executes ‚Üí `second()` is popped

6Ô∏è‚É£ `console.log("First")` executes ‚Üí `first()` is popped

‚úÖ **Output:**

```
First
Second
Third
```

---

## **2Ô∏è‚É£ What is the Event Loop?**

üìå **Definition:**

The **Event Loop** is a mechanism that ensures JavaScript handles asynchronous operations  **without blocking the main thread** .

üìå **How it works:**

1Ô∏è‚É£ JavaScript executes **synchronous** code first (Call Stack).

2Ô∏è‚É£ **Asynchronous tasks** (e.g., `setTimeout`, `fetch`) are sent to Web APIs.

3Ô∏è‚É£ Once completed, their callback functions move to the **Callback Queue (Macrotask Queue)** or  **Microtask Queue** .

4Ô∏è‚É£ The **Event Loop** checks if the Call Stack is empty and pushes pending tasks to execute.

üìå **Example:**

```js
console.log("Start");

setTimeout(() => console.log("Inside setTimeout"), 0);

Promise.resolve().then(() => console.log("Inside Promise"));

console.log("End");
```

üìå **Execution Order:**

1Ô∏è‚É£ `console.log("Start")` ‚Üí Call Stack ‚Üí Executes

2Ô∏è‚É£ `setTimeout` ‚Üí Web API (0ms delay) ‚Üí Moves to Callback Queue

3Ô∏è‚É£ `Promise.resolve()` ‚Üí Moves to **Microtask Queue**

4Ô∏è‚É£ `console.log("End")` ‚Üí Call Stack ‚Üí Executes

5Ô∏è‚É£ Microtask Queue executes first (`console.log("Inside Promise")`)

6Ô∏è‚É£ Macrotask Queue executes (`console.log("Inside setTimeout")`)

‚úÖ **Output:**

```
Start
End
Inside Promise
Inside setTimeout
```

üöÄ **Key Takeaway:** Microtasks (`Promise.then`) execute **before** Macrotasks (`setTimeout`).

---

## **3Ô∏è‚É£ Key Differences: Call Stack vs. Event Loop**

| Feature                      | Call Stack                               | Event Loop                                          |
| ---------------------------- | ---------------------------------------- | --------------------------------------------------- |
| **Purpose**            | Executes synchronous code                | Handles asynchronous operations                     |
| **Structure**          | **LIFO**(Last In, First Out) stack | A loop that moves pending tasks to the stack        |
| **Handles**            | Function execution                       | Tasks from the**Callback & Microtask Queues** |
| **Blocking?**          | Yes (if an operation takes too long)     | No (keeps JavaScript non-blocking)                  |
| **Example Operations** | Normal function calls                    | `setTimeout`,`fetch`,`Promise.then()`         |

---

## **4Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"The Call Stack handles synchronous function execution, while the Event Loop manages asynchronous operations by moving tasks from the queue to the Call Stack."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** What executes first: `setTimeout` or `Promise.resolve()`?

**A:** `Promise.resolve()` executes first because Microtasks have a higher priority than Macrotasks.

2Ô∏è‚É£ **Q:** How does the Event Loop prevent JavaScript from blocking?

**A:** It moves asynchronous tasks to Web APIs, executes synchronous code first, and later processes callbacks from the queue.

3Ô∏è‚É£ **Q:** What happens if the Call Stack is full?

**A:** A **stack overflow** error occurs (e.g., infinite recursion).

üöÄ **Key Takeaway:**

The **Call Stack** executes functions, and the **Event Loop** ensures smooth execution of asynchronous tasks **without blocking** JavaScript.



### ‚úÖ **Q4: What is the difference between the Callback Queue and the Microtask Queue?**

---

## **1Ô∏è‚É£ What is the Callback Queue (Macrotask Queue)?**

üìå **Definition:**

The  **Callback Queue** , also called the  **Macrotask Queue** , stores **macrotasks** (delayed tasks) that are ready to be executed in the next cycle of the  **Event Loop** .

üìå **Examples of Macrotasks:**

‚úÖ `setTimeout(callback, delay)`

‚úÖ `setInterval(callback, interval)`

‚úÖ `setImmediate(callback)` (Node.js)

‚úÖ `I/O tasks` (e.g., file reading, network requests)

üìå **Execution Order:**

* The Event Loop picks one **macrotask** from the Callback Queue and pushes it to the **Call Stack**  **only when the Call Stack is empty** .

---

## **2Ô∏è‚É£ What is the Microtask Queue?**

üìå **Definition:**

The **Microtask Queue** is a **higher priority queue** that stores **microtasks** (short, immediate tasks) that should run  **after the current execution context but before any macrotasks** .

üìå **Examples of Microtasks:**

‚úÖ **Promises (`.then()`, `.catch()`, `.finally()`)**

‚úÖ **`queueMicrotask(callback)`**

‚úÖ **`MutationObserver` (DOM changes listener)**

üìå **Execution Order:**

* The **Microtask Queue** is executed **before the Callback Queue** in each cycle of the Event Loop.

---

## **3Ô∏è‚É£ Key Differences: Callback Queue vs. Microtask Queue**

| Feature                      | Callback Queue (Macrotask)                     | Microtask Queue                                 |
| ---------------------------- | ---------------------------------------------- | ----------------------------------------------- |
| **Execution Priority** | **Lower**                                | **Higher**(Executes before macrotasks)    |
| **Execution Timing**   | After the Call Stack is empty                  | Right after the current task, before macrotasks |
| **Examples**           | `setTimeout`,`setInterval`, I/O operations | `Promise.then()`,`queueMicrotask()`         |
| **Processed By**       | Event Loop in the next cycle                   | Event Loop immediately after the current task   |
| **Delays Execution?**  | Yes (depends on queue order)                   | Almost immediate                                |

---

## **4Ô∏è‚É£ Example: Execution Order in the Event Loop**

```js
console.log("Start");

setTimeout(() => console.log("Inside setTimeout"), 0); // Macrotask

Promise.resolve().then(() => console.log("Inside Promise")); // Microtask

console.log("End");
```

üìå **Step-by-step Execution:**

1Ô∏è‚É£ `console.log("Start")` ‚Üí Executes **(Call Stack - Synchronous Code)**

2Ô∏è‚É£ `setTimeout()` ‚Üí Moves callback to **Callback Queue (Macrotask)**

3Ô∏è‚É£ `Promise.resolve().then()` ‚Üí Moves callback to **Microtask Queue**

4Ô∏è‚É£ `console.log("End")` ‚Üí Executes **(Call Stack - Synchronous Code)**

5Ô∏è‚É£ **Microtask Queue executes first** ‚Üí Logs `"Inside Promise"`

6Ô∏è‚É£ **Callback Queue executes after Microtasks** ‚Üí Logs `"Inside setTimeout"`

‚úÖ **Output:**

```
Start
End
Inside Promise
Inside setTimeout
```

---

## **5Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"The Microtask Queue has higher priority than the Callback Queue. Microtasks (like Promises) execute immediately after synchronous code, while macrotasks (like `setTimeout`) wait for the Call Stack to be empty."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** Why do Microtasks execute before Macrotasks?

**A:** To ensure high-priority tasks (like `Promise.then()`) run before delayed tasks (like `setTimeout`).

2Ô∏è‚É£ **Q:** What happens if a Microtask creates another Microtask?

**A:** The Event Loop processes all Microtasks before moving to the Callback Queue, so the new Microtask executes first.

3Ô∏è‚É£ **Q:** What happens if the Microtask Queue never gets empty?

**A:** It can block the Event Loop, preventing Macrotasks from executing (leading to performance issues).

üöÄ **Key Takeaway:**

The  **Microtask Queue executes first** , ensuring  **faster, high-priority operations** , while the **Callback Queue executes later** for background tasks like timers.



### ‚úÖ **Q5: Why does `Promise.then()` execute before `setTimeout()`?**

---

## **1Ô∏è‚É£ Key Concept: Microtasks vs. Macrotasks**

* JavaScript **prioritizes Microtasks over Macrotasks** in the Event Loop.
* `Promise.then()` is a  **Microtask** , while `setTimeout()` is a  **Macrotask** .
* **Microtasks always execute before Macrotasks** , even if the timeout is `0ms`.

---

## **2Ô∏è‚É£ Event Loop Execution Order**

1Ô∏è‚É£ **Synchronous Code** executes first.

2Ô∏è‚É£ **Microtasks (Promise.then, queueMicrotask, MutationObserver)** execute  **immediately after synchronous code** .

3Ô∏è‚É£ **Macrotasks (setTimeout, setInterval, I/O operations)** execute only  **after the Microtask Queue is empty** .

---

## **3Ô∏è‚É£ Example Code & Execution Order**

```js
console.log("Start");

setTimeout(() => console.log("Inside setTimeout"), 0); // Macrotask

Promise.resolve().then(() => console.log("Inside Promise")); // Microtask

console.log("End");
```

### **Execution Breakdown:**

1Ô∏è‚É£ **Synchronous Code Executes:**

* `"Start"` is logged.
* `setTimeout()` is scheduled  **(added to Macrotask Queue)** .
* `Promise.then()` is scheduled  **(added to Microtask Queue)** .
* `"End"` is logged.

2Ô∏è‚É£ **Microtasks Execute Next (Before Macrotasks)**

* `"Inside Promise"` logs.

3Ô∏è‚É£ **Macrotask Executes After Microtasks**

* `"Inside setTimeout"` logs.

‚úÖ **Final Output:**

```
Start
End
Inside Promise
Inside setTimeout
```

---

## **4Ô∏è‚É£ Why Does `Promise.then()` Run Before `setTimeout()`?**

| Feature                   | **Promise.then() (Microtask)**     | **setTimeout() (Macrotask)**     |
| ------------------------- | ---------------------------------------- | -------------------------------------- |
| **Execution Order** | Executes**before Macrotasks**      | Executes**after Microtasks**     |
| **Queue Type**      | **Microtask Queue**                | **Callback (Macrotask) Queue**   |
| **Priority**        | **Higher**(Runs before Macrotasks) | **Lower**(Runs after Microtasks) |
| **Triggered By**    | `Promise.resolve().then()`             | `setTimeout(callback, delay)`        |

üìå **Key Takeaway:**

Even though `setTimeout()` has a `0ms` delay, it **waits for all microtasks** to complete before executing.

---

## **5Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"Promise.then() executes before setTimeout() because microtasks have higher priority than macrotasks in the Event Loop."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** What if I want `setTimeout()` to run first?

**A:** You can add a delay in the `Promise.then()` using another `setTimeout()`.

2Ô∏è‚É£ **Q:** What happens if a Microtask adds another Microtask?

**A:** The Event Loop processes all Microtasks before moving to the Callback Queue.

3Ô∏è‚É£ **Q:** Can Macrotasks block Microtasks?

**A:** No, Macrotasks always wait for the Microtask Queue to be **completely empty** before executing.

üöÄ **Key Takeaway:**

Microtasks (`Promise.then()`)  **execute first** , ensuring **faster, immediate operations** before delayed Macrotasks (`setTimeout()`).



### ‚úÖ **Q6: Explain how Web APIs work with the Event Loop.**

---

## **1Ô∏è‚É£ Key Concept: Web APIs in the JavaScript Runtime**

* JavaScript itself **is single-threaded** and  **non-blocking** .
* **Web APIs** (provided by the browser) enable **asynchronous operations** like:
  * `setTimeout()`
  * `fetch()`
  * `DOM Manipulation`
  * `Local Storage`
  * `Geolocation`
  * `Event Listeners`

üìå **Web APIs run in the background** and interact with the Event Loop to schedule callbacks.

---

## **2Ô∏è‚É£ How Web APIs Work with the Event Loop**

### **Step-by-Step Execution Flow:**

1Ô∏è‚É£ **JavaScript Execution Begins (Call Stack)**

* Runs synchronous code first.
* Calls to Web APIs are **offloaded** to the browser (not run in the Call Stack).

2Ô∏è‚É£ **Web APIs Handle Asynchronous Tasks**

* The Web API starts an operation **(e.g., HTTP request, Timer, Event Listener).**
* The JavaScript engine **does not wait** and moves to the next task.

3Ô∏è‚É£ **Once Web APIs Complete, They Move Callbacks to Queues:**

* **Timers (`setTimeout`, `setInterval`) ‚Üí Macrotask Queue**
* **Fetch API (`fetch().then()`) ‚Üí Microtask Queue**
* **Event Listeners (`click`, `keydown`) ‚Üí Macrotask Queue**

4Ô∏è‚É£ **The Event Loop Ensures Execution Order:**

* **Microtasks (`Promise.then()`, `MutationObserver`) always execute before Macrotasks (`setTimeout`, `setInterval`).**
* The Call Stack must be **empty** before tasks from the Queue are executed.

---

## **3Ô∏è‚É£ Example: Web API + Event Loop in Action**

```js
console.log("Start");

setTimeout(() => console.log("Inside setTimeout"), 0); // Web API ‚Üí Macrotask Queue

fetch("https://api.example.com")
  .then(() => console.log("Inside Fetch then")) // Web API ‚Üí Microtask Queue

console.log("End");
```

### **Execution Breakdown:**

1Ô∏è‚É£ **Synchronous Execution:**

* `"Start"` logs.
* `setTimeout()` is sent to  **Web API (Timer starts)** .
* `fetch()` is sent to  **Web API (Request starts)** .
* `"End"` logs.

2Ô∏è‚É£ **Web API Completion & Event Loop Processing:**

* **Fetch completes first** ‚Üí Moves `.then()` callback to  **Microtask Queue** .
* **setTimeout completes** ‚Üí Moves callback to  **Macrotask Queue** .

3Ô∏è‚É£ **Event Loop Prioritization:**

* Microtask (`fetch().then()`) runs first ‚Üí Logs `"Inside Fetch then"`.
* Macrotask (`setTimeout()`) runs after ‚Üí Logs `"Inside setTimeout"`.

‚úÖ **Final Output:**

```
Start
End
Inside Fetch then
Inside setTimeout
```

---

## **4Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"Web APIs handle asynchronous operations in the background, then push results into the Event Loop‚Äôs task queues for execution when the Call Stack is empty."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** Where does `setTimeout()` go after execution?

**A:** It moves from Web API ‚Üí Callback Queue (Macrotask) ‚Üí Call Stack.

2Ô∏è‚É£ **Q:** Why does `fetch()` execute before `setTimeout(0)`?

**A:** Because  **fetch.then() is a Microtask** , and Microtasks always run before Macrotasks.

3Ô∏è‚É£ **Q:** What happens if a Microtask schedules another Microtask?

**A:** The Event Loop processes  **all Microtasks before moving to Macrotasks** , meaning newly added Microtasks execute **immediately** before any Macrotask.

üöÄ **Key Takeaway:**

Web APIs  **offload heavy async tasks** , allowing JavaScript to stay **non-blocking** and run smoothly using **the Event Loop.**

### ‚úÖ **Q7: What happens if an expensive operation blocks the Call Stack?**

---

## **1Ô∏è‚É£ Key Concept: The Call Stack and Blocking**

* JavaScript is  **single-threaded** , meaning it has  **one Call Stack** .
* The Call Stack **executes synchronous code** in a **LIFO (Last-In, First-Out)** order.
* If an expensive operation (e.g.,  **infinite loop, large computation, heavy DOM manipulation** )  **blocks the Call Stack** , the following problems occur:
  1. **UI Freezes** ‚Äì No interaction, animations stop.
  2. **Event Listeners Don‚Äôt Respond** ‚Äì Clicks, keyboard inputs won‚Äôt work.
  3. **Delayed Execution of Asynchronous Code** ‚Äì Promises, `setTimeout()`, and `fetch()` won‚Äôt execute until the stack is free.

---

## **2Ô∏è‚É£ Example: Blocking the Call Stack**

```js
console.log("Start");

// Simulating an expensive operation (blocking for 5 seconds)
const start = Date.now();
while (Date.now() - start < 5000) {}  // Blocks execution

console.log("End");
```

### **Execution Breakdown:**

1Ô∏è‚É£  **"Start" logs immediately** .

2Ô∏è‚É£  **The while loop runs for 5 seconds** , blocking everything.

3Ô∏è‚É£ **No async tasks (e.g., `setTimeout()`, `fetch()`) can execute** during this period.

4Ô∏è‚É£  **"End" logs after the loop completes** , but during this time, the UI is frozen.

---

## **3Ô∏è‚É£ How It Affects the Event Loop**

Since the Call Stack is blocked:

* **Microtasks (`Promise.then()`, `MutationObserver`) remain pending.**
* **Macrotasks (`setTimeout()`, `setInterval()`, `fetch()`) do not execute.**
* **User events (clicks, scrolling, typing) do not trigger handlers.**

### **Example: Blocking vs. Non-Blocking Code**

```js
console.log("Start");

setTimeout(() => console.log("Timeout Executed"), 1000); // Macrotask

const start = Date.now();
while (Date.now() - start < 3000) {}  // Blocking operation

console.log("End");
```

### **Expected Output (Blocking):**

```
Start
End
Timeout Executed  // Delayed due to blocking
```

Even though `setTimeout(1000)` was set, it  **won't execute until after `while` completes** , delaying it by ~3 seconds.

---

## **4Ô∏è‚É£ How to Avoid Blocking the Call Stack?**

‚úÖ **1. Use Web Workers for Heavy Computation**

```js
const worker = new Worker("worker.js");
worker.postMessage("Start heavy task");
worker.onmessage = (e) => console.log("Result:", e.data);
```

üìå **Benefit:** Runs the task in a separate thread without blocking the main thread.

‚úÖ **2. Use `setTimeout()` to Break Long Tasks into Chunks**

```js
function expensiveTask() {
  for (let i = 0; i < 1e9; i++) {
    if (i % 1e7 === 0) setTimeout(() => {}, 0); // Allows Event Loop to process tasks
  }
}
setTimeout(expensiveTask, 0); 
```

üìå **Benefit:** The Call Stack clears, allowing other tasks to execute.

‚úÖ **3. Use `requestAnimationFrame()` for Smooth UI Updates**

```js
function animate() {
  requestAnimationFrame(animate);
  console.log("Rendering Frame...");
}
requestAnimationFrame(animate);
```

üìå **Benefit:** Prevents UI lag while executing animations.

‚úÖ **4. Use `async/await` with `setTimeout()` for Large Loops**

```js
async function processLargeData() {
  for (let i = 0; i < 1e7; i++) {
    if (i % 1e6 === 0) await new Promise((res) => setTimeout(res, 0)); // Non-blocking
  }
}
processLargeData();
```

üìå **Benefit:** Breaks execution into small chunks, freeing the Call Stack.

---

## **5Ô∏è‚É£ Interview Summary & Quick Answer**

üìù **One-Liner Answer:**

*"If an expensive operation blocks the Call Stack, it freezes the UI, delays async operations, and prevents event listeners from firing. To prevent this, use Web Workers, `setTimeout()`, or `requestAnimationFrame()` to break tasks into smaller chunks."*

‚úÖ **Common Follow-up Questions:**

1Ô∏è‚É£ **Q:** Why does `setTimeout(0)` not execute immediately?

**A:** Because the Event Loop schedules it as a Macrotask, which executes only after the Call Stack is empty.

2Ô∏è‚É£ **Q:** How can Web Workers help prevent blocking?

**A:** Web Workers run in a separate thread, handling computation-heavy tasks without affecting the main thread.

3Ô∏è‚É£ **Q:** Why is `requestAnimationFrame()` better for animations than `setInterval()`?

**A:** It syncs with the browser‚Äôs refresh rate (~60 FPS), preventing UI jank.

üöÄ **Key Takeaway:**

To keep JavaScript  **non-blocking and responsive** , break heavy computations into **small tasks** using **async techniques.**
