# ðŸš€ **JavaScript Throttling â€“ Interview Guide**

Throttling is an optimization technique that **limits the execution of a function** to a fixed time interval. It improves performance by reducing the frequency of function calls, making it useful for event listeners like `scroll`, `resize`, and `keypress`.

---

## âœ… **Q1: What is Throttling in JavaScript?**

âœ” **Definition:** Throttling ensures that a function is **executed at most once** in a specified time interval, even if it's triggered multiple times.

âœ” **Use Case:** Optimizing performance-heavy operations (e.g., `scroll`, `resize`, `mousemove`).

ðŸ”¹ **Example Without Throttling:**

```js
window.addEventListener("resize", () => {
  console.log("Window resized!"); // Gets called excessively
});
```

ðŸ’¡ **Problem:** The event fires too frequently, affecting performance.

---

## âœ… **Q2: How to Implement Throttling?**

### **1ï¸âƒ£ Basic Throttling Function**

âœ” **Uses `setTimeout` to delay execution**

âœ” **Ensures execution occurs at fixed intervals**

ðŸ”¹ **Implementation:**

```js
function throttle(func, limit) {
  let inThrottle;

  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// âœ… Usage:
const logMessage = () => console.log("Throttled function executed");
window.addEventListener("resize", throttle(logMessage, 2000));
```

ðŸ”¹ **Behavior:**

âœ” The function runs immediately.

âœ” Further calls within `limit` (2 seconds) are ignored.

---

## âœ… **Q3: How is Throttling Different from Debouncing?**

| Feature   | **Throttling**                 | **Debouncing**              |
| --------- | ------------------------------------ | --------------------------------- |
| Execution | Executes function at fixed intervals | Delays execution until inactivity |
| Use Case  | Scroll, Resize, Mousemove            | Search Input, Auto-Save           |
| Example   | Limiting API calls per second        | Waiting for user to stop typing   |

---

## âœ… **Q4: How to Implement Throttling Using Timestamps?**

âœ” **More efficient than `setTimeout`** (No extra timers)

ðŸ”¹ **Implementation:**

```js
function throttle(func, limit) {
  let lastFunc;
  let lastRan;

  return function (...args) {
    const context = this;
    const now = Date.now();

    if (!lastRan) {
      func.apply(context, args);
      lastRan = now;
    } else {
      clearTimeout(lastFunc);
      lastFunc = setTimeout(() => {
        if (now - lastRan >= limit) {
          func.apply(context, args);
          lastRan = now;
        }
      }, limit - (now - lastRan));
    }
  };
}

// âœ… Usage:
const throttledScroll = throttle(() => console.log("Scrolled!"), 1000);
window.addEventListener("scroll", throttledScroll);
```

ðŸ”¹ **How it Works?**

âœ” Executes immediately on the first call.

âœ” Uses `Date.now()` to track the last execution.

âœ” Uses `setTimeout` to handle the next execution after `limit`.

---

## âœ… **Q5: Throttling a Function with Leading & Trailing Calls**

âœ” **`leading: true`** â†’ Executes immediately.

âœ” **`trailing: true`** â†’ Ensures last call gets executed.

ðŸ”¹ **Implementation:**

```js
function throttle(func, delay, options = { leading: true, trailing: true }) {
  let lastCall = 0;
  let timeout;

  return function (...args) {
    const now = Date.now();
    const context = this;

    if (!lastCall && !options.leading) lastCall = now;

    const remainingTime = delay - (now - lastCall);

    if (remainingTime <= 0 || remainingTime > delay) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      lastCall = now;
      func.apply(context, args);
    } else if (!timeout && options.trailing) {
      timeout = setTimeout(() => {
        lastCall = options.leading ? Date.now() : 0;
        timeout = null;
        func.apply(context, args);
      }, remainingTime);
    }
  };
}

// âœ… Usage:
const throttledClick = throttle(() => console.log("Button Clicked!"), 2000, {
  leading: true,
  trailing: false,
});

document.getElementById("btn").addEventListener("click", throttledClick);
```

ðŸ”¹ **Options Explanation:**

âœ” `leading: true` â†’ Runs the function immediately on the first call.

âœ” `trailing: false` â†’ Prevents execution after the last event.

---

## ðŸš€ **Interview Summary:**

| Feature                | **Throttling**          |
| ---------------------- | ----------------------------- |
| **Execution**    | Fixed intervals               |
| **Use Case**     | Scroll, Resize, API Calls     |
| **Methods**      | `setTimeout`,`Date.now()` |
| **Optimization** | Reduces function calls        |

---

## ðŸš€ **Final Takeaways for Interviews:**

âœ… Throttling **limits execution frequency** instead of delaying it.

âœ… Implement  **both `setTimeout` and timestamp-based throttling** .

âœ… Be able to  **compare throttling vs. debouncing** .

âœ… Know  **how to implement leading & trailing execution** .

ðŸ”¥ Master these concepts, and you'll ace JavaScript performance questions! ðŸš€
